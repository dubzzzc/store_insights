<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Store Insights Dashboard</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    
<style>
  :root {
    font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    --page-bg: #0b3d5c;
    --page-bg-accent: #0fa8b8;
    --panel-bg: #ffffff;
    --panel-border: rgba(15, 23, 42, 0.12);
    --panel-soft: rgba(255, 255, 255, 0.1);
    --primary: #0ea5e9;
    --primary-strong: #0284c7;
    --primary-soft: rgba(14, 165, 233, 0.12);
    --neutral: #f1f5f9;
    --neutral-soft: rgba(148, 163, 184, 0.18);
    --text: #0f172a;
    --text-muted: #475569;
    --danger: #dc2626;
    color-scheme: light dark;
  }

  * {
    box-sizing: border-box;
  }

  body {
    margin: 0;
    min-height: 100vh;
    background: linear-gradient(135deg, var(--page-bg), var(--page-bg-accent));
    color: var(--text);
    display: flex;
    justify-content: center;
  }

  .app-shell {
    width: 100%;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
  }

  header {
    color: #fff;
    padding: clamp(1.5rem, 4vw, 2.75rem) clamp(1.5rem, 6vw, 3.5rem) clamp(1.25rem, 3vw, 2.25rem);
  }

  .header-bar {
    margin: 0 auto;
    width: min(1200px, 100%);
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
  }

  .header-top {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 1.5rem;
    flex-wrap: wrap;
  }

  .brand {
    display: flex;
    align-items: center;
    gap: 0.75rem;
  }

  .brand-icon {
    width: 2.75rem;
    height: 2.75rem;
    border-radius: 1rem;
    background: rgba(255, 255, 255, 0.12);
    display: grid;
    place-items: center;
    font-weight: 700;
    font-size: 1.15rem;
  }

  .brand h1 {
    margin: 0;
    font-size: clamp(1.5rem, 4vw, 2.1rem);
    letter-spacing: 0.02em;
  }

  .session-meta {
    position: relative;
    display: flex;
    flex-direction: column;
    gap: 0.35rem;
    text-align: right;
  }

  .session-greeting {
    font-size: clamp(1rem, 2.4vw, 1.25rem);
    font-weight: 600;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: flex-end;
    gap: 0.5rem;
    user-select: none;
    transition: opacity 0.2s ease;
  }

  .session-greeting:hover {
    opacity: 0.9;
  }

  .session-greeting::after {
    content: '▼';
    font-size: 0.7rem;
    opacity: 0.7;
    transition: transform 0.2s ease;
  }

  .session-greeting.open::after {
    transform: rotate(180deg);
  }

  .session-subtext {
    color: rgba(226, 232, 240, 0.75);
    font-size: 0.95rem;
  }

  .profile-menu {
    position: absolute;
    top: 100%;
    right: 0;
    margin-top: 0.5rem;
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(14px);
    border-radius: 1rem;
    box-shadow: 0 18px 40px rgba(15, 23, 42, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.4);
    min-width: 220px;
    overflow: hidden;
    z-index: 1000;
    display: none;
  }

  .profile-menu.open {
    display: block;
  }

  .profile-menu-item {
    padding: 0.85rem 1.25rem;
    color: var(--text);
    font-size: 0.95rem;
    cursor: pointer;
    transition: background 0.2s ease;
    border-bottom: 1px solid rgba(15, 23, 42, 0.08);
  }

  .profile-menu-item:last-child {
    border-bottom: none;
  }

  .profile-menu-item:hover {
    background: var(--neutral);
  }

  .profile-menu-item.store-select {
    padding: 1rem 1.25rem;
  }

  .profile-menu-item.store-select label {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    font-weight: 600;
    font-size: 0.85rem;
    color: var(--text-muted);
    cursor: default;
  }

  .profile-menu-item.store-select select {
    width: 100%;
    padding: 0.65rem 1rem;
    border-radius: 0.75rem;
    border: 1px solid var(--panel-border);
    background: #fff;
    color: var(--text);
    font-size: 0.95rem;
    cursor: pointer;
  }

  .profile-menu-item.store-select select:focus {
    outline: 2px solid var(--primary);
    outline-offset: 2px;
  }

  .profile-menu-item.sign-out {
    color: var(--danger);
    font-weight: 600;
  }

  .profile-menu-item.sign-out:hover {
    background: rgba(220, 38, 38, 0.1);
  }

  .weather-compact {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.85rem;
    color: rgba(226, 232, 240, 0.85);
    cursor: pointer;
    transition: opacity 0.2s ease;
    margin-top: 0.25rem;
  }

  .weather-compact:hover {
    opacity: 0.9;
  }

  .weather-temp {
    font-weight: 600;
    color: rgba(255, 255, 255, 0.95);
  }

  .weather-desc {
    font-size: 0.8rem;
    color: rgba(226, 232, 240, 0.7);
  }

  .weather-loading {
    color: rgba(226, 232, 240, 0.5);
  }

  .spinner {
    display: inline-block;
    width: 14px;
    height: 14px;
    border: 2px solid rgba(255, 255, 255, 0.3);
    border-top-color: rgba(255, 255, 255, 0.9);
    border-radius: 50%;
    animation: spin 0.6s linear infinite;
    vertical-align: middle;
    margin-right: 6px;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  .loading-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(248, 250, 252, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10;
    border-radius: 0.75rem;
  }

  .loading-overlay .spinner {
    width: 32px;
    height: 32px;
    border-width: 3px;
    margin-right: 0;
  }

  .app-main {
    flex: 1;
    background: #f8fafc;
    border-top-left-radius: 2.25rem;
    border-top-right-radius: 2.25rem;
    margin-top: clamp(1.25rem, 3vw, 2.25rem);
    padding: clamp(1.75rem, 4vw, 3rem) clamp(1.25rem, 5vw, 3rem) clamp(3rem, 6vw, 4rem);
  }

  .app-main-inner {
    margin: 0 auto;
    width: min(1200px, 100%);
    display: flex;
    flex-direction: column;
    gap: clamp(1.5rem, 3vw, 2.25rem);
  }

  .module-nav {
    display: flex;
    gap: 0.75rem;
    flex-wrap: wrap;
    background: rgba(255, 255, 255, 0.75);
    backdrop-filter: blur(14px);
    padding: 0.85rem;
    border-radius: 1.1rem;
    box-shadow: 0 18px 40px rgba(15, 23, 42, 0.12);
    border: 1px solid rgba(255, 255, 255, 0.4);
  }

  .module-nav select {
    display: none;
  }

  .module-nav button {
    border: none;
    border-radius: 0.85rem;
    padding: 0.65rem 1.4rem;
    font-size: 0.95rem;
    font-weight: 600;
    color: var(--text-muted);
    background: transparent;
    cursor: pointer;
    transition: background 0.2s ease, color 0.2s ease, transform 0.2s ease;
  }

  .module-nav button:hover,
  .module-nav button:focus {
    color: var(--text);
    background: var(--neutral);
    outline: none;
    transform: translateY(-1px);
  }

  .module-nav button.active {
    background: var(--primary);
    color: #fff;
    box-shadow: 0 12px 30px rgba(14, 165, 233, 0.25);
  }

  @media (max-width: 768px) {
    .module-nav {
      flex-wrap: nowrap;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      scrollbar-width: none;
    }
    .module-nav::-webkit-scrollbar {
      display: none;
    }
    .module-nav button {
      flex-shrink: 0;
      white-space: nowrap;
    }
  }

  @media (max-width: 640px) {
    .module-nav {
      display: block;
      padding: 0;
      background: transparent;
      border: none;
      box-shadow: none;
    }
    .module-nav button {
      display: none;
    }
    .module-nav select {
      display: block;
      width: 100%;
      padding: 0.85rem 1rem;
      border-radius: 1.1rem;
      border: 1px solid var(--panel-border);
      background: rgba(255, 255, 255, 0.75);
      backdrop-filter: blur(14px);
      font-size: 0.95rem;
      font-weight: 600;
      color: var(--text);
      cursor: pointer;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%230f172a' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 1rem center;
      padding-right: 2.5rem;
    }
    .module-nav select:focus {
      outline: 2px solid var(--primary);
      outline-offset: 2px;
    }
  }

  .panel {
    background: var(--panel-bg);
    border-radius: 1.5rem;
    padding: clamp(1.5rem, 3vw, 2.25rem);
    box-shadow: 0 24px 55px rgba(15, 23, 42, 0.06);
    display: grid;
    gap: clamp(1.5rem, 3vw, 2rem);
    border: 1px solid var(--panel-border);
  }

  .panel.sales-panel {
    gap: clamp(1.75rem, 3.5vw, 2.5rem);
    background: linear-gradient(165deg, rgba(14, 165, 233, 0.12), rgba(14, 165, 233, 0.02));
    border: 1px solid rgba(14, 165, 233, 0.18);
  }

  .sales-hero {
    display: flex;
    flex-wrap: wrap;
    gap: 1.5rem;
    justify-content: space-between;
    align-items: stretch;
    background: rgba(255, 255, 255, 0.65);
    border-radius: 1.25rem;
    padding: clamp(1rem, 3vw, 1.75rem);
    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.55);
  }

  .sales-hero-left {
    display: flex;
    flex: 1 1 260px;
    gap: 1.1rem;
    align-items: center;
  }

  .hero-icon {
    width: 3.25rem;
    height: 3.25rem;
    border-radius: 1.1rem;
    display: grid;
    place-items: center;
    background: linear-gradient(135deg, rgba(14, 165, 233, 0.3), rgba(14, 165, 233, 0.05));
    color: var(--primary-strong);
    font-weight: 700;
    font-size: 1.1rem;
  }

  .hero-copy {
    display: grid;
    gap: 0.35rem;
  }

  .hero-eyebrow {
    font-size: 0.8rem;
    text-transform: uppercase;
    letter-spacing: 0.16em;
    color: var(--primary-strong);
    font-weight: 700;
  }

  .hero-title {
    margin: 0;
    font-size: clamp(1.45rem, 3vw, 1.85rem);
  }

  .hero-subtitle {
    font-size: 0.9rem;
    color: var(--text-muted);
  }

  .hero-dates {
    display: flex;
    flex-wrap: wrap;
    gap: 0.35rem 0.65rem;
    font-size: 0.85rem;
    color: var(--text-muted);
    align-items: center;
  }

  .hero-dates span {
    display: flex;
    align-items: center;
    gap: 0.3rem;
  }

  .hero-divider {
    padding: 0 0.35rem;
    opacity: 0.65;
  }

  .sales-hero-metric {
    flex: 0 0 auto;
    min-width: 200px;
    background: linear-gradient(135deg, rgba(14, 165, 233, 0.35), rgba(14, 165, 233, 0.05));
    border-radius: 1rem;
    padding: 1.1rem 1.4rem;
    display: grid;
    gap: 0.4rem;
    align-content: center;
    border: 1px solid rgba(14, 165, 233, 0.25);
  }

  .sales-hero-metric span {
    font-size: 0.85rem;
    color: var(--text-muted);
  }

  .sales-hero-metric strong {
    font-size: clamp(1.8rem, 4vw, 2.2rem);
    line-height: 1.1;
  }

  @media (max-width: 640px) {
    .sales-hero {
      align-items: stretch;
    }

    .sales-hero-metric {
      width: 100%;
    }
  }

  .sales-chart-card {
    border-radius: 1.25rem;
    border: 1px solid rgba(15, 23, 42, 0.08);
    background: rgba(255, 255, 255, 0.92);
    padding: clamp(1rem, 2.5vw, 1.6rem);
    display: grid;
    gap: 1.25rem;
  }

  .sales-chart-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 1rem;
    flex-wrap: wrap;
  }

  .sales-chart-header h3 {
    margin: 0;
    font-size: 1.1rem;
  }

  .chart-subtitle {
    margin: 0;
    font-size: 0.85rem;
    color: var(--text-muted);
  }

  .sales-chart-grid {
    display: grid;
    gap: 1.5rem;
  }

  @media (min-width: 960px) {
    .sales-chart-grid.with-legend {
      grid-template-columns: minmax(0, 2fr) minmax(0, 1fr);
      align-items: stretch;
    }
  }

  .sales-chart-grid .chart-legend {
    border-radius: 1rem;
    background: rgba(255, 255, 255, 0.75);
    padding: 1rem 1.25rem;
    box-shadow: 0 16px 32px rgba(15, 23, 42, 0.08);
    border: 1px solid rgba(14, 165, 233, 0.15);
  }

  .sales-view-tabs {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 0.75rem;
  }

  .sales-view-tabs button {
    border: none;
    border-radius: 0.9rem;
    padding: 0.85rem 1.1rem;
    font-weight: 600;
    font-size: 0.95rem;
    background: rgba(255, 255, 255, 0.7);
    color: var(--text-muted);
    cursor: pointer;
    box-shadow: 0 12px 28px rgba(15, 23, 42, 0.08);
    transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease, color 0.2s ease;
  }

  .sales-view-tabs button:hover,
  .sales-view-tabs button:focus {
    transform: translateY(-1px);
    color: var(--text);
    background: rgba(255, 255, 255, 0.9);
    outline: none;
  }

  .sales-view-tabs button.active {
    background: linear-gradient(135deg, var(--primary), var(--primary-strong));
    color: #fff;
    box-shadow: 0 16px 32px rgba(14, 165, 233, 0.35);
  }

  .panel-header {
    display: flex;
    flex-wrap: wrap;
    justify-content: space-between;
    align-items: center;
    gap: 1rem;
  }

  .panel-title {
    margin: 0;
    font-size: clamp(1.25rem, 2.8vw, 1.55rem);
    letter-spacing: 0.01em;
  }

  .summary-grid {
    display: grid;
    gap: 1rem;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  }

  .summary-card {
    background: linear-gradient(135deg, rgba(14, 165, 233, 0.18), rgba(14, 165, 233, 0.04));
    border-radius: 1rem;
    padding: 1rem 1.25rem;
    display: grid;
    gap: 0.3rem;
    border: 1px solid rgba(14, 165, 233, 0.15);
  }

  .summary-card h3 {
    margin: 0;
    font-size: 0.85rem;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: var(--text-muted);
  }

  .summary-card strong {
    font-size: clamp(1.3rem, 3vw, 1.6rem);
  }

  .summary-card span {
    font-size: 0.85rem;
    color: var(--text-muted);
  }

  .chart-card {
    border-radius: 1.25rem;
    border: 1px solid var(--panel-border);
    padding: 1.25rem;
    display: grid;
    gap: 0.75rem;
    background: #fff;
  }

  .insight-grid {
    display: grid;
    gap: 1.5rem;
  }

  .insight-grid.two-column {
    grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
  }

  .insight-grid.two-column > .sync-card,
  .insight-grid.two-column > .table-card,
  .insight-grid.two-column > .chart-card {
    height: 100%;
  }

  .chart-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 1rem;
    flex-wrap: wrap;
  }

  .chart-header h3 {
    margin: 0;
    font-size: 1rem;
  }

  .chart-area {
    position: relative;
    width: 100%;
    min-height: clamp(220px, 40vh, 360px);
  }

  .chart-legend {
    display: grid;
    gap: 0.6rem;
  }

  .legend-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 0.75rem;
  }

  .legend-label {
    display: flex;
    align-items: center;
    gap: 0.6rem;
    font-weight: 600;
    color: var(--text);
  }

  .legend-color {
    width: 0.85rem;
    height: 0.85rem;
    border-radius: 0.35rem;
  }

  .legend-value {
    font-weight: 600;
    color: var(--text-muted);
  }

  .table-card {
    border-radius: 1.25rem;
    border: 1px solid var(--panel-border);
    overflow: hidden;
    background: #fff;
  }

  .table-card h3 {
    margin: 0;
    padding: 1.1rem 1.4rem 0;
    font-size: 1rem;
  }

  .table-wrapper {
    overflow-x: auto;
  }

  table {
    width: 100%;
    border-collapse: collapse;
  }

  th,
  td {
    padding: 0.85rem 1rem;
    text-align: left;
    border-bottom: 1px solid rgba(148, 163, 184, 0.25);
    font-size: 0.95rem;
  }

  th {
    text-transform: uppercase;
    font-size: 0.75rem;
    letter-spacing: 0.08em;
    color: var(--text-muted);
  }

  tr:last-child td {
    border-bottom: none;
  }

  .empty-state {
    background: var(--neutral);
    border-radius: 1rem;
    padding: 1.5rem;
    text-align: center;
    color: var(--text-muted);
  }

  .purchase-list,
  .history-table {
    border-radius: 1.25rem;
    border: 1px solid var(--panel-border);
    overflow: hidden;
    background: #fff;
  }

  .purchase-row {
    display: grid;
    gap: 0.5rem;
    grid-template-columns: 2fr auto;
    padding: 0.9rem 1.25rem;
    border-bottom: 1px solid rgba(148, 163, 184, 0.18);
  }

  .purchase-row:last-child {
    border-bottom: none;
  }

  .purchase-row strong {
    font-size: 1rem;
  }

  .search-bar {
    display: flex;
    gap: 0.75rem;
    flex-wrap: wrap;
  }

  .search-bar input {
    flex: 1;
    min-width: 200px;
    padding: 0.75rem 1rem;
    border-radius: 0.9rem;
    border: 1px solid rgba(148, 163, 184, 0.35);
  }

  .search-bar button {
    border: none;
    padding: 0.75rem 1.4rem;
    border-radius: 0.9rem;
    background: var(--primary);
    color: #fff;
    font-weight: 600;
    cursor: pointer;
  }

  .sync-card {
    border-radius: 1.25rem;
    border: 1px solid var(--panel-border);
    padding: 1.25rem;
    background: #fff;
    display: grid;
    gap: 1rem;
  }

  .sync-table {
    width: 100%;
    border-collapse: collapse;
  }

  .sync-table th,
  .sync-table td {
    padding: 0.75rem 0.5rem;
    border-bottom: 1px solid rgba(148, 163, 184, 0.25);
    text-align: left;
    font-size: 0.9rem;
  }

  .sync-status {
    text-transform: capitalize;
    font-weight: 600;
  }

  .sync-status.success {
    color: #0f766e;
  }

  .sync-status.failed {
    color: #dc2626;
  }

  .sync-status.pending {
    color: #92400e;
  }

  .sync-status.running {
    color: #2563eb;
  }

  button:disabled,
  .sign-out:disabled {
    opacity: 0.55;
    cursor: not-allowed;
    transform: none;
  }

  .admin-layout {
    padding: clamp(1.5rem, 4vw, 3rem);
    width: min(1100px, 100%);
    margin: 0 auto;
    display: grid;
    gap: clamp(1.5rem, 3vw, 2.5rem);
  }

  .admin-card {
    background: #fff;
    border-radius: 1.25rem;
    border: 1px solid var(--panel-border);
    padding: clamp(1.5rem, 3vw, 2.25rem);
    box-shadow: 0 24px 55px rgba(15, 23, 42, 0.06);
    display: grid;
    gap: 1.25rem;
  }

  .admin-card h2 {
    margin: 0;
    font-size: clamp(1.25rem, 3vw, 1.5rem);
  }

  .admin-grid {
    display: grid;
    gap: 1.25rem;
    grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
  }

  .admin-list {
    border: 1px solid rgba(148, 163, 184, 0.2);
    border-radius: 1rem;
    overflow: hidden auto;
    max-height: 360px;
  }

  .admin-user {
    padding: 1rem 1.25rem;
    border-bottom: 1px solid rgba(148, 163, 184, 0.18);
    display: grid;
    gap: 0.35rem;
    cursor: pointer;
  }

  .admin-user:last-child {
    border-bottom: none;
  }

  .admin-user.active {
    background: var(--primary-soft);
  }

  .badge {
    display: inline-flex;
    align-items: center;
    padding: 0.3rem 0.6rem;
    border-radius: 999px;
    background: rgba(14, 165, 233, 0.18);
    color: var(--primary-strong);
    font-size: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    font-weight: 600;
  }

  label {
    display: flex;
    flex-direction: column;
    gap: 0.4rem;
    font-weight: 600;
    color: var(--text);
  }

  input,
  select,
  button {
    font: inherit;
  }

  input,
  select {
    background: #fff;
    color: inherit;
  }

  input::placeholder {
    color: var(--text-muted);
  }

  .form-grid {
    display: grid;
    gap: 1rem;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  }

  .inline-actions {
    display: flex;
    gap: 0.75rem;
    flex-wrap: wrap;
  }

  .inline-actions input[type="date"] {
    padding: 0.75rem 1rem;
    border-radius: 0.9rem;
    border: 2px solid rgba(99, 102, 241, 0.3);
    background: rgba(99, 102, 241, 0.1);
    color: var(--text);
    font-weight: 500;
    font-size: 0.95rem;
    cursor: pointer;
    transition: all 0.2s ease;
    min-width: 150px;
  }

  .inline-actions input[type="date"]:hover {
    border-color: rgba(99, 102, 241, 0.5);
    background: rgba(99, 102, 241, 0.15);
  }

  .inline-actions input[type="date"]:focus {
    outline: none;
    border-color: rgba(99, 102, 241, 0.8);
    background: rgba(99, 102, 241, 0.2);
    box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
  }

  .inline-actions input[type="date"]::-webkit-calendar-picker-indicator {
    cursor: pointer;
    filter: invert(0.4) sepia(1) saturate(5) hue-rotate(220deg);
    padding: 0.25rem;
    border-radius: 0.25rem;
  }

  .inline-actions input[type="date"]::-webkit-calendar-picker-indicator:hover {
    background: rgba(99, 102, 241, 0.2);
    filter: invert(0.3) sepia(1) saturate(5) hue-rotate(220deg);
  }

  .inline-actions button {
    padding: 0.75rem 1.25rem;
    border-radius: 0.9rem;
    border: none;
    font-weight: 600;
    cursor: pointer;
    background: var(--primary);
    color: #fff;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
  }

  .inline-actions button.secondary {
    background: rgba(148, 163, 184, 0.2);
    color: var(--text);
  }

  .inline-actions button:hover,
  .inline-actions button:focus {
    outline: none;
    transform: translateY(-1px);
    box-shadow: 0 10px 24px rgba(15, 23, 42, 0.12);
  }

  .status-pill {
    display: inline-flex;
    align-items: center;
    padding: 0.3rem 0.75rem;
    border-radius: 999px;
    background: rgba(148, 163, 184, 0.18);
    color: var(--text-muted);
    font-size: 0.8rem;
    font-weight: 600;
  }

  .login-layout {
    min-height: 100vh;
    display: grid;
    place-items: center;
    padding: clamp(1.5rem, 6vw, 3rem);
    background: linear-gradient(135deg, rgba(15, 23, 42, 0.95), rgba(19, 78, 110, 0.95));
    position: relative;
    overflow: hidden;
  }

  .login-layout::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: 
      radial-gradient(circle at 20% 50%, rgba(14, 165, 233, 0.15) 0%, transparent 50%),
      radial-gradient(circle at 80% 80%, rgba(139, 92, 246, 0.15) 0%, transparent 50%);
    pointer-events: none;
  }

  .login-card {
    width: min(480px, 100%);
    background: rgba(15, 23, 42, 0.85);
    backdrop-filter: blur(16px);
    color: #fff;
    border-radius: 1.75rem;
    padding: clamp(2rem, 5vw, 3rem);
    display: grid;
    gap: 2rem;
    box-shadow: 0 40px 80px rgba(15, 23, 42, 0.5), 0 0 0 1px rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.12);
    position: relative;
    z-index: 1;
  }

  .login-card h1 {
    margin: 0;
    text-align: center;
    font-size: clamp(2rem, 5vw, 2.5rem);
    font-weight: 700;
    background: linear-gradient(135deg, #fff 0%, rgba(148, 163, 184, 0.9) 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    letter-spacing: -0.02em;
  }

  .login-card p {
    margin: 0;
    text-align: center;
    color: rgba(226, 232, 240, 0.75);
    font-size: 0.95rem;
  }

  .login-options {
    display: grid;
    gap: 1rem;
  }

  .login-option-btn {
    padding: 1.25rem 1.5rem;
    border-radius: 1rem;
    border: 2px solid rgba(148, 163, 184, 0.2);
    background: rgba(15, 23, 42, 0.6);
    color: #fff;
    font-weight: 600;
    font-size: 1rem;
    cursor: pointer;
    transition: all 0.3s ease;
    text-align: center;
    position: relative;
    overflow: hidden;
  }

  .login-option-btn::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
    transition: left 0.5s ease;
  }

  .login-option-btn:hover::before {
    left: 100%;
  }

  .login-option-btn:hover {
    border-color: rgba(14, 165, 233, 0.5);
    background: rgba(14, 165, 233, 0.1);
    transform: translateY(-2px);
    box-shadow: 0 8px 24px rgba(14, 165, 233, 0.2);
  }

  .login-option-btn:active {
    transform: translateY(0);
  }

  .mobility-form {
    display: grid;
    gap: 1.25rem;
    margin-top: 0.5rem;
    padding-top: 1.5rem;
    border-top: 1px solid rgba(148, 163, 184, 0.2);
  }

  .mobility-form label {
    display: grid;
    gap: 0.5rem;
    color: rgba(255, 255, 255, 0.9);
    font-size: 0.9rem;
    font-weight: 500;
  }

  .mobility-form-row {
    display: grid;
    grid-template-columns: 2fr 1fr;
    gap: 1rem;
  }

  .mobility-form input {
    background: rgba(15, 23, 42, 0.7);
    border: 1px solid rgba(148, 163, 184, 0.3);
    color: #fff;
    padding: 0.85rem 1rem;
    border-radius: 0.75rem;
    font-size: 0.95rem;
    transition: all 0.2s ease;
  }

  .mobility-form input:focus {
    outline: none;
    border-color: rgba(14, 165, 233, 0.6);
    background: rgba(15, 23, 42, 0.85);
    box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.1);
  }

  .mobility-form input::placeholder {
    color: rgba(226, 232, 240, 0.5);
  }

  .mobility-actions {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 0.75rem;
    margin-top: 0.5rem;
  }

  .mobility-actions button {
    padding: 0.85rem 1.25rem;
    border-radius: 0.75rem;
    border: none;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    font-size: 0.95rem;
  }

  .mobility-actions button.primary {
    background: var(--primary);
    color: #fff;
  }

  .mobility-actions button.primary:hover {
    transform: translateY(-1px);
    box-shadow: 0 8px 20px rgba(14, 165, 233, 0.3);
  }

  .mobility-actions button.secondary {
    background: rgba(15, 23, 42, 0.6);
    border: 1px solid rgba(148, 163, 184, 0.3);
    color: rgba(255, 255, 255, 0.9);
  }

  .mobility-actions button.secondary:hover {
    background: rgba(15, 23, 42, 0.8);
    border-color: rgba(148, 163, 184, 0.5);
  }

  .login-card label {
    color: rgba(255, 255, 255, 0.9);
  }

  .login-card input {
    background: rgba(15, 23, 42, 0.65);
    border: 1px solid rgba(148, 163, 184, 0.25);
    color: #fff;
    padding: 0.8rem 1rem;
    border-radius: 0.9rem;
    transition: all 0.2s ease;
  }

  .login-card input:focus {
    outline: none;
    border-color: rgba(14, 165, 233, 0.6);
    background: rgba(15, 23, 42, 0.85);
    box-shadow: 0 0 0 3px rgba(14, 165, 233, 0.1);
  }

  .login-card input::placeholder {
    color: rgba(226, 232, 240, 0.6);
  }

  .login-card button {
    padding: 0.85rem 1.25rem;
    border-radius: 0.95rem;
    border: none;
    font-weight: 600;
    cursor: pointer;
    background: var(--primary);
    color: #fff;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
  }

  .login-card button:hover,
  .login-card button:focus {
    outline: none;
    transform: translateY(-1px);
    box-shadow: 0 12px 28px rgba(14, 165, 233, 0.35);
  }

  .login-card button.secondary {
    background: rgba(15, 23, 42, 0.55);
    border: 1px solid rgba(148, 163, 184, 0.35);
  }

  .login-error,
  .admin-error {
    padding: 0.9rem 1.1rem;
    border-radius: 0.95rem;
    background: rgba(220, 38, 38, 0.18);
    color: #fecaca;
    font-weight: 600;
  }

  .login-message,
  .admin-message {
    padding: 0.9rem 1.1rem;
    border-radius: 0.95rem;
    background: rgba(16, 185, 129, 0.2);
    color: #d1fae5;
    font-weight: 600;
  }

  @media (max-width: 768px) {
    header {
      padding: clamp(1.25rem, 5vw, 2rem);
    }

    .header-controls {
      flex-direction: column;
      align-items: stretch;
    }

    .store-controls {
      width: 100%;
    }

    .store-controls select {
      width: 100%;
    }

    .profile-menu {
      min-width: 200px;
      right: 0;
    }

    .session-greeting {
      font-size: 0.95rem;
    }

    .weather-compact {
      font-size: 0.8rem;
      margin-top: 0.2rem;
    }

    .weather-desc {
      font-size: 0.75rem;
    }


    .chart-area {
      height: 260px;
    }

    .panel {
      padding: clamp(1.25rem, 4vw, 2rem);
    }

    .chart-card,
    .table-card,
    .sync-card,
    .purchase-list,
    .history-table {
      border-radius: 1rem;
    }
  }

  /* Modal styles */
  .modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(15, 23, 42, 0.6);
    backdrop-filter: blur(4px);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2000;
    padding: 1rem;
  }

  .modal-content {
    background: var(--panel-bg);
    border-radius: 1rem;
    box-shadow: 0 20px 60px rgba(15, 23, 42, 0.3);
    max-width: 600px;
    width: 100%;
    max-height: 90vh;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
  }

  .modal-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 1.5rem;
    border-bottom: 1px solid var(--panel-border);
  }

  .modal-header h3 {
    margin: 0;
    font-size: 1.25rem;
    font-weight: 600;
    color: var(--text);
  }

  .modal-close {
    background: none;
    border: none;
    font-size: 2rem;
    line-height: 1;
    color: var(--text-muted);
    cursor: pointer;
    padding: 0;
    width: 2rem;
    height: 2rem;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 0.5rem;
    transition: background 0.2s ease, color 0.2s ease;
  }

  .modal-close:hover {
    background: var(--neutral);
    color: var(--text);
  }

  .modal-body {
    padding: 1.5rem;
    flex: 1;
    overflow-y: auto;
  }

  .modal-body p {
    margin: 0.5rem 0;
    color: var(--text);
  }

  .modal-body table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 0.5rem;
  }

  .modal-body table th {
    background: var(--neutral);
    font-weight: 600;
    color: var(--text);
  }

  .modal-body table td,
  .modal-body table th {
    padding: 0.75rem;
    border-bottom: 1px solid var(--panel-border);
  }

  .modal-body table tbody tr:hover {
    background: var(--neutral-soft);
  }
</style>

  </head>
  <body>
    <div id="root"></div>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

    <script type="text/babel">
      const { useState, useMemo, useEffect, useRef, useCallback } = React;
      const API_BASE = '';

      const STORAGE_KEYS = {
        token: 'store-insights/token',
        stores: 'store-insights/stores',
        selectedStore: 'store-insights/selected-store',
        adminKey: 'store-insights/admin-key',
        role: 'store-insights/role',
        profile: 'store-insights/profile',
        operationsCache: 'store-insights/operations-cache',
        salesCache: 'store-insights/sales-cache',
        quickCache: 'store-insights/quick-cache',
        tendersCache: 'store-insights/tenders-cache',
        gatewayCache: 'store-insights/gateway-cache',
        syncCache: 'store-insights/sync-cache',
      };

      const getStorage = () => {
        try {
          if (typeof window === 'undefined' || !window.localStorage) {
            return null;
          }
          return window.localStorage;
        } catch (error) {
          console.warn('Storage unavailable', error);
          return null;
        }
      };

      const storageBackend = getStorage();

      const storage = {
        get(key, fallback = null) {
          if (!storageBackend) return fallback;
          const rawValue = storageBackend.getItem(key);
          if (rawValue === null) return fallback;
          try {
            return JSON.parse(rawValue);
          } catch (error) {
            return rawValue;
          }
        },
        set(key, value) {
          if (!storageBackend) return;
          if (value === undefined || value === null) {
            storageBackend.removeItem(key);
            return;
          }
          const serialized =
            typeof value === 'string' ? value : JSON.stringify(value);
          storageBackend.setItem(key, serialized);
        },
        remove(key) {
          if (!storageBackend) return;
          storageBackend.removeItem(key);
        },
        clearSession() {
          if (!storageBackend) return;
          Object.entries(STORAGE_KEYS).forEach(([name, key]) => {
            if (name === 'adminKey') return;
            storageBackend.removeItem(key);
          });
        },
      };

      const currencyFormatter = new Intl.NumberFormat(undefined, {
        style: 'currency',
        currency: 'USD',
        minimumFractionDigits: 2,
      });

      const quantityFormatter = new Intl.NumberFormat(undefined, {
        minimumFractionDigits: 0,
        maximumFractionDigits: 2,
      });

      const integerFormatter = new Intl.NumberFormat(undefined, {
        maximumFractionDigits: 0,
      });

      const formatCurrency = (value) => {
        const numeric = Number(value ?? 0);
        if (Number.isNaN(numeric)) {
          return '—';
        }
        return currencyFormatter.format(numeric);
      };

      const formatQuantity = (value) => {
        const numeric = Number(value ?? 0);
        if (Number.isNaN(numeric)) {
          return '—';
        }
        return quantityFormatter.format(numeric);
      };

      const formatInteger = (value) => {
        const numeric = Number(value ?? 0);
        if (Number.isNaN(numeric)) {
          return '—';
        }
        return integerFormatter.format(numeric);
      };

      const formatDate = (value) => {
        if (!value) return '—';
        const isoLike =
          typeof value === 'string' && !value.includes('T') ? `${value}T00:00:00` : value;
        const date = new Date(isoLike);
        if (Number.isNaN(date.getTime())) {
          return String(value);
        }
        return date.toLocaleDateString(undefined, {
          month: 'short',
          day: 'numeric',
          year: 'numeric',
        });
      };

      const toNumber = (value, fallback = 0) => {
        const numeric = Number(value);
        return Number.isNaN(numeric) ? fallback : numeric;
      };

      // Generic caching utility for API calls
      const createCacheKey = (type, query, options = {}) => {
        const queryParams = new URLSearchParams(query.replace('?', ''));
        const storeParam = queryParams.get('store') || 'default';
        const startParam = queryParams.get('start') || '';
        const endParam = queryParams.get('end') || '';
        const poStartParam = queryParams.get('po_start') || '';
        const poEndParam = queryParams.get('po_end') || '';
        const invStartParam = queryParams.get('inv_start') || '';
        const invEndParam = queryParams.get('inv_end') || '';
        
        // For operations, use month-based key
        if (type === 'operations') {
          const now = new Date();
          return `${type}_${storeParam}_${now.getFullYear()}_${now.getMonth()}`;
        }
        
        // For other types, include date ranges in key
        const parts = [type, storeParam];
        if (startParam) parts.push(`s:${startParam}`);
        if (endParam) parts.push(`e:${endParam}`);
        if (poStartParam) parts.push(`pos:${poStartParam}`);
        if (poEndParam) parts.push(`poe:${poEndParam}`);
        if (invStartParam) parts.push(`is:${invStartParam}`);
        if (invEndParam) parts.push(`ie:${invEndParam}`);
        
        // Include any additional query params that affect the result
        if (options.includeParams) {
          options.includeParams.forEach(param => {
            const value = queryParams.get(param);
            if (value) parts.push(`${param}:${value}`);
          });
        }
        
        return parts.join('_');
      };

      const getCachedData = (cacheKey, storageKey, ttlMinutes = 5) => {
        try {
          const cached = storage.get(storageKey, {});
          if (cached[cacheKey] && cached[cacheKey].data) {
            const cacheAge = Date.now() - (cached[cacheKey].timestamp || 0);
            const ttlMs = ttlMinutes * 60 * 1000;
            if (cacheAge < ttlMs) {
              return cached[cacheKey].data;
            }
          }
        } catch (e) {
          // If cache read fails, return null to fetch fresh data
        }
        return null;
      };

      const setCachedData = (cacheKey, storageKey, data) => {
        try {
          const cached = storage.get(storageKey, {});
          cached[cacheKey] = {
            data: data,
            timestamp: Date.now(),
          };
          storage.set(storageKey, cached);
        } catch (e) {
          // If cache write fails, continue - data is still returned
        }
      };

      const clearSalesCache = () => {
        try {
          storage.set(STORAGE_KEYS.salesCache, {});
        } catch (e) {
          // Ignore errors
        }
      };

      const clearAllCaches = () => {
        try {
          // Clear all cache keys to force fresh data when store changes
          storage.set(STORAGE_KEYS.salesCache, {});
          storage.set(STORAGE_KEYS.operationsCache, {});
          storage.set(STORAGE_KEYS.tendersCache, {});
          storage.set(STORAGE_KEYS.gatewayCache, {});
          storage.set(STORAGE_KEYS.quickCache, {});
          storage.set(STORAGE_KEYS.syncCache, {});
        } catch (e) {
          // Ignore errors
        }
      };

      const getStoreIdentifier = (store) => {
        if (!store) return '';
        if (store.store_id !== undefined && store.store_id !== null) {
          return String(store.store_id);
        }
        if (store.store_db) {
          return String(store.store_db);
        }
        if (store.store_name) {
          return String(store.store_name);
        }
        return '';
      };

      const formatRole = (role) => {
        if (!role) return '—';
        return role.charAt(0).toUpperCase() + role.slice(1);
      };

      const decodeTokenPayload = (token) => {
        if (!token || typeof window === 'undefined' || typeof window.atob !== 'function') {
          return null;
        }

        try {
          const segments = token.split('.');
          if (segments.length < 2) {
            return null;
          }

          const payload = segments[1].replace(/-/g, '+').replace(/_/g, '/');
          const padded = payload.padEnd(Math.ceil(payload.length / 4) * 4, '=');
          return JSON.parse(window.atob(padded));
        } catch (error) {
          console.warn('Unable to decode token payload', error);
          return null;
        }
      };

      const decodeRoleFromToken = (token) => {
        const payload = decodeTokenPayload(token);
        return (payload && payload.role) || '';
      };

      const StoreSelector = ({ stores, selectedStore, onChange }) => {
        if (!stores?.length) return null;
        const options = stores.map((store) => ({
          value: getStoreIdentifier(store) || store.store_db || String(store.store_name || ''),
          label: store.store_name || store.store_db || `Store #${store.store_id}`,
        }));

        const selectedValue = getStoreIdentifier(selectedStore) || options[0]?.value || '';

        useEffect(() => {
          if (!selectedStore && options.length) {
            const first = stores.find((s) => getStoreIdentifier(s) === options[0].value) || stores[0];
            onChange(first);
          }
        }, [stores, selectedStore, onChange]);

        if (stores.length === 1) {
          return (
            <div>
              <span className="metric-label">Store</span>
              <div>{options[0]?.label}</div>
            </div>
          );
        }

        return (
          <label>
            Store
            <select
              value={selectedValue}
              onChange={(event) => {
                const selected = stores.find((store) => getStoreIdentifier(store) === event.target.value);
                onChange(selected);
              }}
            >
              {options.map((option) => (
                <option key={option.value} value={option.value}>
                  {option.label}
                </option>
              ))}
            </select>
          </label>
        );
      };

      const HourlySalesChart = ({ data }) => {
        const canvasRef = useRef(null);
        const chartRef = useRef(null);

        useEffect(() => {
          const canvas = canvasRef.current;
          if (!canvas) return;

          if (!data?.length) {
            if (chartRef.current) {
              chartRef.current.destroy();
              chartRef.current = null;
            }
            return;
          }

          const labels = data.map((entry) => entry.hour);
          const totals = data.map((entry) => Number(entry.total_sales) || 0);

          if (chartRef.current) {
            chartRef.current.data.labels = labels;
            chartRef.current.data.datasets[0].data = totals;
            chartRef.current.update();
          } else {
            chartRef.current = new Chart(canvas, {
              type: 'bar',
              data: {
                labels,
                datasets: [
                  {
                    data: totals,
                    backgroundColor: '#0ea5e9',
                    borderRadius: 6,
                    maxBarThickness: 32,
                  },
                ],
              },
              options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                  x: { grid: { display: false } },
                  y: {
                    ticks: {
                      callback: (value) => formatCurrency(value),
                    },
                    grid: { color: 'rgba(148, 163, 184, 0.2)' },
                  },
                },
                plugins: {
                  legend: { display: false },
                  tooltip: {
                    callbacks: {
                      label: (context) => formatCurrency(context.raw),
                    },
                  },
                },
              },
            });
          }

          return () => {
            if (chartRef.current) {
              chartRef.current.destroy();
              chartRef.current = null;
            }
          };
        }, [data]);

        if (!data?.length) {
          return <div className="empty-state">No hourly sales recorded.</div>;
        }

        return <canvas ref={canvasRef}></canvas>;
      };

      const BreakdownPieChart = ({ data, labelKey }) => {
        const canvasRef = useRef(null);
        const chartRef = useRef(null);

        useEffect(() => {
          const canvas = canvasRef.current;
          if (!canvas) return;

          if (!data?.length) {
            if (chartRef.current) {
              chartRef.current.destroy();
              chartRef.current = null;
            }
            return;
          }

          const labels = data.map((entry) => entry[labelKey] || '—');
          const totals = data.map((entry) => Number(entry.total_sales) || 0);
          const colors = totals.map((_, index) => {
            const palette = [
              '#0ea5e9',
              '#6366f1',
              '#f97316',
              '#22d3ee',
              '#14b8a6',
              '#facc15',
              '#fb7185',
              '#8b5cf6',
              '#ec4899',
              '#f43f5e',
            ];
            return palette[index % palette.length];
          });

          if (chartRef.current) {
            chartRef.current.data.labels = labels;
            chartRef.current.data.datasets[0].data = totals;
            chartRef.current.data.datasets[0].backgroundColor = colors;
            chartRef.current.update();
          } else {
            chartRef.current = new Chart(canvas, {
              type: 'doughnut',
              data: {
                labels,
                datasets: [
                  {
                    data: totals,
                    backgroundColor: colors,
                    borderWidth: 0,
                  },
                ],
              },
              options: {
                responsive: true,
                maintainAspectRatio: false,
                cutout: '60%',
                plugins: {
                  legend: { display: false },
                  tooltip: {
                    callbacks: {
                      label: (context) => formatCurrency(context.raw),
                    },
                  },
                },
              },
            });
          }

          return () => {
            if (chartRef.current) {
              chartRef.current.destroy();
              chartRef.current = null;
            }
          };
        }, [data, labelKey]);

        if (!data?.length) {
          return <div className="empty-state">No data for this view.</div>;
        }

        return <canvas ref={canvasRef}></canvas>;
      };

      const WeatherCard = ({ compact = false }) => {
        const [weather, setWeather] = useState({ temp: null, desc: '', place: '' });
        const [error, setError] = useState('');
        const [unit, setUnit] = useState('F'); // 'C' or 'F' - default to Fahrenheit

        useEffect(() => {
          const fetchCityName = async (lat, lon) => {
            try {
              const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&addressdetails=1`;
              const res = await fetch(url, { headers: { 'User-Agent': 'StoreInsights/1.0' } });
              const data = await res.json();
              const city = data?.address?.city || data?.address?.town || data?.address?.village 
                || data?.address?.municipality || data?.address?.county || 'Unknown';
              return city;
            } catch (e) {
              return null;
            }
          };

          const fetchWeather = async (lat, lon) => {
            try {
              const cityName = await fetchCityName(lat, lon);
              const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,weather_code&timezone=auto`;
              const res = await fetch(url);
              const data = await res.json();
              const code = (data && data.current && data.current.weather_code) || null;
              const temp = (data && data.current && data.current.temperature_2m) || null;
              const labels = {
                0: 'Clear', 1: 'Mainly clear', 2: 'Partly cloudy', 3: 'Overcast', 45: 'Fog', 48: 'Rime fog',
                51: 'Drizzle', 53: 'Drizzle', 55: 'Drizzle', 56: 'Freezing drizzle', 57: 'Freezing drizzle',
                61: 'Rain', 63: 'Rain', 65: 'Rain', 66: 'Freezing rain', 67: 'Freezing rain',
                71: 'Snow', 73: 'Snow', 75: 'Snow', 77: 'Snow grains',
                80: 'Rain showers', 81: 'Rain showers', 82: 'Rain showers',
                85: 'Snow showers', 86: 'Snow showers',
                95: 'Thunderstorm', 96: 'Thunderstorm', 99: 'Thunderstorm',
              };
              setWeather({ temp, desc: labels[code] || '—', place: cityName || '' });
            } catch (e) {
              setError('Unable to load weather');
            }
          };

          if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
              (pos) => fetchWeather(pos.coords.latitude, pos.coords.longitude),
              () => fetchWeather(47.6062, -122.3321) // fallback: Seattle
            );
          } else {
            fetchWeather(47.6062, -122.3321);
          }
        }, []);

        const toggleUnit = () => {
          setUnit(unit === 'C' ? 'F' : 'C');
        };

        const displayTemp = () => {
          if (weather.temp === null) return '—';
          if (unit === 'F') {
            const fahrenheit = (weather.temp * 9/5) + 32;
            return `${Math.round(fahrenheit)}°F`;
          }
          return `${Math.round(weather.temp)}°C`;
        };

        if (error) return null; // Don't show error in compact mode
        
        if (compact) {
          // Compact version for header
          return (
            <div 
              className="weather-compact"
              onClick={toggleUnit}
              title="Click to toggle °C / °F"
            >
              {weather.temp !== null ? (
                <>
                  <span className="weather-temp">{displayTemp()}</span>
                  {weather.desc && <span className="weather-desc">{weather.desc}</span>}
                </>
              ) : (
                <span className="weather-loading">—</span>
              )}
            </div>
          );
        }
        
        // Full version for dashboard
        return (
          <div className="summary-grid">
            <div className="summary-card" style={{ cursor: 'pointer' }} onClick={toggleUnit} title="Click to toggle °C / °F">
              <h3>Current</h3>
              <strong>{displayTemp()}</strong>
              <span>{weather.desc}</span>
              {weather.place ? <span style={{ fontSize: '0.75rem', marginTop: '0.25rem' }}>{weather.place}</span> : null}
            </div>
          </div>
        );
      };

      const BreakdownLegend = ({ items, labelKey }) => {
        if (!items?.length) return null;
        const palette = [
          '#0ea5e9',
          '#6366f1',
          '#f97316',
          '#22d3ee',
          '#14b8a6',
          '#facc15',
          '#fb7185',
          '#8b5cf6',
          '#ec4899',
          '#f43f5e',
        ];
        return (
          <div className="chart-legend">
            {items.map((entry, index) => (
              <div className="legend-row" key={`${entry[labelKey]}-${index}`}>
                <div className="legend-label">
                  <span
                    className="legend-color"
                    style={{ background: palette[index % palette.length] }}
                  ></span>
                  {entry[labelKey] || '—'}
                </div>
                <div className="legend-value">
                  {formatCurrency(entry.total_sales)}
                  {entry.percentage !== undefined ? ` · ${entry.percentage}%` : ''}
                </div>
              </div>
            ))}
          </div>
        );
      };

      const SalesChart = ({ sales }) => {
        const canvasRef = useRef(null);
        const chartRef = useRef(null);

        useEffect(() => {
          const canvas = canvasRef.current;
          if (!canvas) return;

          if (!sales?.length) {
            if (chartRef.current) {
              chartRef.current.destroy();
              chartRef.current = null;
            }
            return;
          }

          const labels = sales.map((item) => item.date).reverse();
          const totals = sales.map((item) => item.total_sales).reverse();
          const qty = sales.map((item) => item.total_items_sold).reverse();

          if (chartRef.current) {
            chartRef.current.data.labels = labels;
            chartRef.current.data.datasets[0].data = totals;
            chartRef.current.data.datasets[1].data = qty;
            chartRef.current.update();
            return;
          }

          chartRef.current = new Chart(canvas, {
            type: 'line',
            data: {
              labels,
              datasets: [
                {
                  label: 'Sales ($)',
                  data: totals,
                  borderColor: '#2563eb',
                  backgroundColor: 'rgba(37, 99, 235, 0.12)',
                  tension: 0.35,
                  fill: true,
                  yAxisID: 'y',
                },
                {
                  label: 'Items Sold',
                  data: qty,
                  borderColor: '#f97316',
                  backgroundColor: 'rgba(249, 115, 22, 0.12)',
                  tension: 0.35,
                  fill: true,
                  yAxisID: 'y1',
                },
              ],
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                y: {
                  position: 'left',
                  title: { display: true, text: 'Sales ($)' },
                },
                y1: {
                  position: 'right',
                  grid: { drawOnChartArea: false },
                  title: { display: true, text: 'Items' },
                },
              },
              plugins: {
                legend: { display: true },
                tooltip: { mode: 'index', intersect: false },
              },
            },
          });

          return () => {
            if (chartRef.current) {
              chartRef.current.destroy();
              chartRef.current = null;
            }
          };
        }, [sales]);

        if (!sales?.length) {
          return <div className="empty-state">No sales data available for charting.</div>;
        }

        return <canvas ref={canvasRef} height="220"></canvas>;
      };

      const SyncTable = ({ logs }) => {
        if (!logs?.length) {
          return <div className="empty-state">No sync activity logged yet.</div>;
        }

        const formatNumber = (value) => {
          if (value === null || value === undefined) return '—';
          const parsed = Number(value);
          return Number.isNaN(parsed) ? value : parsed.toLocaleString();
        };

        return (
          <div className="table-wrapper">
            <table>
              <thead>
                <tr>
                  <th>Store</th>
                  <th>Status</th>
                  <th>Started</th>
                  <th>Finished</th>
                  <th>Records</th>
                  <th>Message</th>
                </tr>
              </thead>
              <tbody>
                {logs.map((log) => (
                  <tr key={`${log.id}-${log.started_at}`}> 
                    <td>{log.store_name || log.store_db || '—'}</td>
                    <td>
                      <span className="status-pill" data-status={(log.status || '').toLowerCase()}>
                        {log.status || '—'}
                      </span>
                    </td>
                    <td>{log.started_at ? new Date(log.started_at).toLocaleString() : '—'}</td>
                    <td>{log.finished_at ? new Date(log.finished_at).toLocaleString() : '—'}</td>
                    <td>{formatNumber(log.records_processed)}</td>
                    <td>{log.message || '—'}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        );
      };




const CreateUserForm = ({ onSubmit, isSubmitting, knownStores = [], onEnsureStore }) => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [fullName, setFullName] = useState('');
  const [role, setRole] = useState('owner');
  const [storeDb, setStoreDb] = useState('');
  const [storeUser, setStoreUser] = useState('');
  const [storePass, setStorePass] = useState('');
  const [storeName, setStoreName] = useState('');
  const [formError, setFormError] = useState('');
  const [storeSearch, setStoreSearch] = useState('');
  const suggestions = useMemo(() => {
    const q = (storeSearch || '').toLowerCase();
    if (!q) return knownStores;
    return knownStores.filter((s) =>
      (s.label || '').toLowerCase().includes(q) || (s.store_db || '').toLowerCase().includes(q)
    );
  }, [storeSearch, knownStores]);

  const applySuggestion = (value) => {
    const choice = knownStores.find(
      (s) => s.store_db === value || s.label === value
    );
    if (choice) {
      setStoreDb(choice.store_db || '');
      setStoreName(choice.store_name || choice.label || '');
    }
  };

  const handleSubmit = async (event) => {
    event.preventDefault();
    setFormError('');

    if (!email.trim() || !password.trim()) {
      setFormError('Email and password are required');
      return;
    }

    const stores = [];
    if (storeDb.trim() || storeUser.trim() || storePass.trim() || storeName.trim()) {
      if (!storeDb.trim() || !storeUser.trim() || !storePass.trim()) {
        setFormError('Store database, user, and password are required for the first assignment');
        return;
      }
      stores.push({
        store_db: storeDb.trim(),
        db_user: storeUser.trim(),
        db_pass: storePass,
        store_name: storeName.trim() || undefined,
      });
    }

    const payload = {
      email: email.trim(),
      password: password.trim(),
      full_name: fullName.trim() || undefined,
      user_role: role,
      stores,
    };

    const success = await onSubmit(payload);
    if (success) {
      setEmail('');
      setPassword('');
      setFullName('');
      setRole('owner');
      setStoreDb('');
      setStoreUser('');
      setStorePass('');
      setStoreName('');
    }
  };

  return (
    <form className="admin-card" onSubmit={handleSubmit}>
      <h2 className="panel-title">Create user</h2>
      {formError ? <div className="admin-error">{formError}</div> : null}
      <div className="form-grid">
        <label>
          Search stores
          <input
            type="text"
            value={storeSearch}
            onChange={(e) => setStoreSearch(e.target.value)}
            list="known-stores-datalist"
            placeholder="Start typing to search known stores"
            disabled={isSubmitting}
            onBlur={(e) => applySuggestion(e.target.value)}
            onKeyDown={(e) => {
              if (e.key === 'Enter') applySuggestion(storeSearch);
            }}
          />
          <datalist id="known-stores-datalist">
            {suggestions.map((s) => (
              <option key={s.store_db} value={s.store_db}>{s.label}</option>
            ))}
          </datalist>
        </label>
      </div>
      <div className="form-grid">
        <label>
          Email
          <input
            type="email"
            value={email}
            onChange={(event) => setEmail(event.target.value)}
            placeholder="manager@example.com"
            disabled={isSubmitting}
            required
          />
        </label>
        <label>
          Password
          <input
            type="password"
            value={password}
            onChange={(event) => setPassword(event.target.value)}
            placeholder="Minimum 8 characters"
            disabled={isSubmitting}
            required
          />
        </label>
        <label>
          Full name (optional)
          <input
            type="text"
            value={fullName}
            onChange={(event) => setFullName(event.target.value)}
            disabled={isSubmitting}
          />
        </label>
        <label>
          Role
          <select value={role} onChange={(event) => setRole(event.target.value)} disabled={isSubmitting}>
            <option value="owner">Owner</option>
            <option value="user">User</option>
            <option value="admin">Admin</option>
          </select>
        </label>
      </div>
      <div className="form-grid">
        <label>
          Store database
          <input
            type="text"
            value={storeDb}
            onChange={(event) => setStoreDb(event.target.value)}
            placeholder="spirits_6885"
            disabled={isSubmitting}
          />
        </label>
        <label>
          DB user
          <input
            type="text"
            value={storeUser}
            onChange={(event) => setStoreUser(event.target.value)}
            placeholder="store_reader"
            disabled={isSubmitting}
          />
        </label>
        <label>
          DB password
          <input
            type="password"
            value={storePass}
            onChange={(event) => setStorePass(event.target.value)}
            placeholder="secret"
            disabled={isSubmitting}
          />
        </label>
        <label>
          Store name
          <input
            type="text"
            value={storeName}
            onChange={(event) => setStoreName(event.target.value)}
            placeholder="Downtown Spirits"
            disabled={isSubmitting}
          />
        </label>
      </div>
      <div className="inline-actions">
        <button
          type="button"
          className="secondary"
          disabled={isSubmitting || !storeDb || !storeUser || !storePass}
          onClick={async () => {
            if (!onEnsureStore) return;
            await onEnsureStore({ store_db: storeDb.trim(), db_user: storeUser.trim(), db_pass: storePass });
          }}
        >
          Ensure database exists
        </button>
        <button type="submit" disabled={isSubmitting}>
          {isSubmitting ? 'Creating…' : 'Create user'}
        </button>
      </div>
    </form>
  );
};

const AddStoreForm = ({ user, onSubmit, isSubmitting }) => {
  const [storeDb, setStoreDb] = useState('');
  const [storeUser, setStoreUser] = useState('');
  const [storePass, setStorePass] = useState('');
  const [storeName, setStoreName] = useState('');
  const [formError, setFormError] = useState('');

  const handleSubmit = async (event) => {
    event.preventDefault();
    setFormError('');

    if (!storeDb.trim() || !storeUser.trim() || !storePass.trim()) {
      setFormError('Database, user, and password are required');
      return;
    }

    const success = await onSubmit({
      store_db: storeDb.trim(),
      db_user: storeUser.trim(),
      db_pass: storePass,
      store_name: storeName.trim() || undefined,
    });

    if (success) {
      setStoreDb('');
      setStoreUser('');
      setStorePass('');
      setStoreName('');
    }
  };

  return (
    <form className="admin-card" onSubmit={handleSubmit}>
      <h2 className="panel-title">Add store to {user?.email || 'user'}</h2>
      {formError ? <div className="admin-error">{formError}</div> : null}
      <div className="form-grid">
        <label>
          Store database
          <input
            type="text"
            value={storeDb}
            onChange={(event) => setStoreDb(event.target.value)}
            placeholder="spirits_6885"
            disabled={isSubmitting}
          />
        </label>
        <label>
          DB user
          <input
            type="text"
            value={storeUser}
            onChange={(event) => setStoreUser(event.target.value)}
            placeholder="store_reader"
            disabled={isSubmitting}
          />
        </label>
        <label>
          DB password
          <input
            type="password"
            value={storePass}
            onChange={(event) => setStorePass(event.target.value)}
            placeholder="secret"
            disabled={isSubmitting}
          />
        </label>
        <label>
          Store name
          <input
            type="text"
            value={storeName}
            onChange={(event) => setStoreName(event.target.value)}
            placeholder="Downtown Spirits"
            disabled={isSubmitting}
          />
        </label>
      </div>
      <div className="inline-actions">
        <button type="submit" disabled={isSubmitting}>
          {isSubmitting ? 'Adding…' : 'Add store'}
        </button>
      </div>
    </form>
  );
};

const StoreAssignments = ({ user, onRemoveStore, isProcessing }) => {
  if (!user?.stores?.length) {
    return <div className="empty-state">No store assignments yet.</div>;
  }

  return (
    <div className="store-list">
      {user.stores.map((store) => {
        const identifier = getStoreIdentifier(store) || store.id || store.store_db;
        return (
          <div className="store-item" key={`${user.id}-${identifier}`}>
            <strong>{store.store_name || store.store_db || 'Store'}</strong>
            <span>{store.store_db || '—'}</span>
            <div className="inline-actions">
              <button
                type="button"
                className="secondary"
                onClick={() => onRemoveStore(user.id, identifier)}
                disabled={isProcessing}
              >
                Remove
              </button>
            </div>
          </div>
        );
      })}
    </div>
  );
};

// Admin: manage users by store selection
const AdminStoreAccess = ({ users, onRemoveStore, isProcessing }) => {
  const collectStores = useCallback(() => {
    const unique = new Map();
    (users || []).forEach((user) => {
      (user.stores || []).forEach((store) => {
        const id = getStoreIdentifier(store) || store.id || store.store_db;
        if (!id) return;
        if (!unique.has(id)) {
          unique.set(id, {
            id,
            label: store.store_name || store.store_db || String(id),
          });
        }
      });
    });
    return Array.from(unique.values()).sort((a, b) => a.label.localeCompare(b.label));
  }, [users]);

  const allStores = collectStores();
  const [storeQuery, setStoreQuery] = React.useState('');
  const stores = React.useMemo(() => {
    if (!storeQuery) return allStores;
    const q = storeQuery.toLowerCase();
    return allStores.filter((s) => s.label.toLowerCase().includes(q) || String(s.id).toLowerCase().includes(q));
  }, [allStores, storeQuery]);
  const [selectedStoreId, setSelectedStoreId] = React.useState(() => stores[0]?.id || '');

  React.useEffect(() => {
    if (!allStores.length) {
      setSelectedStoreId('');
      return;
    }
    if (!selectedStoreId || !allStores.some((s) => s.id === selectedStoreId)) {
      setSelectedStoreId(allStores[0].id);
    }
  }, [allStores, selectedStoreId]);

  const filteredUsers = React.useMemo(() => {
    if (!selectedStoreId) return [];
    return (users || []).filter((u) =>
      (u.stores || []).some((s) => (getStoreIdentifier(s) || s.id || s.store_db) === selectedStoreId)
    );
  }, [users, selectedStoreId]);

  return (
    <section className="admin-card">
      <h2 className="panel-title">Manage access by store</h2>
      {!allStores.length ? (
        <div className="empty-state">No stores found across users.</div>
      ) : (
        <>
          <div className="form-grid">
            <label>
              Search stores
              <input
                type="text"
                value={storeQuery}
                onChange={(e) => setStoreQuery(e.target.value)}
                placeholder="Type to filter stores"
              />
            </label>
            <label>
              Store
              <select value={selectedStoreId} onChange={(e) => setSelectedStoreId(e.target.value)}>
                {stores.map((s) => (
                  <option key={s.id} value={s.id}>{s.label}</option>
                ))}
              </select>
            </label>
          </div>

          {!filteredUsers.length ? (
            <div className="empty-state">No users currently assigned to this store.</div>
          ) : (
            <div className="admin-list">
              {filteredUsers.map((u) => (
                <div key={`${selectedStoreId}-${u.id}`} className="admin-user">
                  <strong>{u.email}</strong>
                  <span>{u.full_name || '—'}</span>
                  <span>Role: {formatRole(u.user_role)}</span>
                  <div className="inline-actions">
                    <button
                      type="button"
                      className="secondary"
                      onClick={() => onRemoveStore(u.id, selectedStoreId)}
                      disabled={isProcessing}
                    >
                      Remove from store
                    </button>
                  </div>
                </div>
              ))}
            </div>
          )}
        </>
      )}
    </section>
  );
};

const UserList = ({ users, selectedUserId, onSelectUser }) => {
  if (!users?.length) {
    return <div className="empty-state">No users found yet.</div>;
  }

  return (
    <div className="admin-list">
      {users.map((user) => (
        <div
          key={user.id}
          className={`admin-user ${selectedUserId === user.id ? 'active' : ''}`}
          onClick={() => onSelectUser(user.id)}
        >
          <strong>{user.email}</strong>
          <span>{user.full_name || '—'}</span>
          <span>Role: {formatRole(user.user_role)}</span>
          <span>{(user.stores?.length || 0).toString()} store{user.stores?.length === 1 ? '' : 's'}</span>
        </div>
      ))}
    </div>
  );
};

const AdminPanel = ({
  users,
  selectedUserId,
  onSelectUser,
  onRefresh,
  onCreateUser,
  onAddStore,
  onRemoveStore,
  onEnsureStore,
  isLoading,
  isProcessing,
  error,
  message,
}) => {
  const selectedUser = users.find((user) => user.id === selectedUserId) || users[0] || null;

  const knownStores = useMemo(() => {
    const map = new Map();
    (users || []).forEach((u) => {
      (u.stores || []).forEach((s) => {
        const id = getStoreIdentifier(s) || s.id || s.store_db;
        if (!id) return;
        if (!map.has(id)) {
          map.set(id, {
            id,
            label: s.store_name || s.store_db || String(id),
            store_db: s.store_db || String(id),
            store_name: s.store_name || undefined,
          });
        }
      });
    });
    return Array.from(map.values()).sort((a, b) => a.label.localeCompare(b.label));
  }, [users]);

  useEffect(() => {
    if (!selectedUser && users.length) {
      onSelectUser(users[0].id);
    }
  }, [users, selectedUser, onSelectUser]);

  return (
    <div className="admin-grid">
      <AdminStoreAccess users={users} onRemoveStore={onRemoveStore} isProcessing={isProcessing} />
      <section className="admin-card">
        <div className="panel-header">
          <div>
            <h2 className="panel-title">Users</h2>
            <p className="session-subtext">Manage dashboard accounts and their store access.</p>
          </div>
          <button
            type="button"
            className="sign-out"
            onClick={onRefresh}
            disabled={isLoading || isProcessing}
          >
            Refresh
          </button>
        </div>
        {error ? <div className="admin-error">{error}</div> : null}
        {message ? <div className="admin-message">{message}</div> : null}
        {isLoading ? (
          <div className="empty-state">Loading users…</div>
        ) : (
          <UserList users={users} selectedUserId={selectedUser?.id} onSelectUser={onSelectUser} />
        )}
        <CreateUserForm
          onSubmit={onCreateUser}
          isSubmitting={isProcessing}
          knownStores={knownStores}
          onEnsureStore={onEnsureStore}
        />
      </section>
      <section className="admin-card">
        <h2 className="panel-title">Store assignments</h2>
        {selectedUser ? (
          <>
            <div className="summary-grid">
              <div className="summary-card">
                <h3>User</h3>
                <strong>{selectedUser.email}</strong>
                <span>{selectedUser.full_name || '—'}</span>
              </div>
              <div className="summary-card">
                <h3>Role</h3>
                <strong>{formatRole(selectedUser.user_role)}</strong>
                <span>{(selectedUser.stores?.length || 0).toString()} store(s)</span>
              </div>
            </div>
            <StoreAssignments
              user={selectedUser}
              onRemoveStore={onRemoveStore}
              isProcessing={isProcessing}
            />
            <AddStoreForm user={selectedUser} onSubmit={onAddStore} isSubmitting={isProcessing} />
          </>
        ) : (
          <div className="empty-state">Select a user to manage their stores.</div>
        )}
      </section>
    </div>
  );
};

const AdminView = ({
  hasKey,
  users,
  selectedUserId,
  onSelectUser,
  onRefresh,
  onCreateUser,
  onAddStore,
  onRemoveStore,
  onEnsureStore,
  isLoading,
  isProcessing,
  error,
  message,
}) => {
  if (!hasKey) {
    return (
      <section className="admin-card">
        <h2 className="panel-title">Admin access unavailable</h2>
        {error ? <div className="admin-error">{error}</div> : null}
        <p className="session-subtext">
          Configure the <code>ADMIN_API_KEY</code> environment variable on the server to enable admin tools.
        </p>
      </section>
    );
  }

  return (
    <AdminPanel
      users={users}
      selectedUserId={selectedUserId}
      onSelectUser={onSelectUser}
      onRefresh={onRefresh}
      onCreateUser={onCreateUser}
      onAddStore={onAddStore}
      onRemoveStore={onRemoveStore}
      onEnsureStore={onEnsureStore}
      isLoading={isLoading}
      isProcessing={isProcessing}
      error={error}
      message={message}
    />
  );
};
      const LoginForm = ({ onSubmit, isLoading, error }) => {
        const [email, setEmail] = useState('');
        const [password, setPassword] = useState('');

        const submit = (event) => {
          event.preventDefault();
          onSubmit({ email, password });
        };

        return (
          <form onSubmit={submit}>
            <label htmlFor="email">
              Email
              <input
                id="email"
                type="email"
                placeholder="you@example.com"
                value={email}
                onChange={(event) => setEmail(event.target.value)}
                required
              />
            </label>
            <label htmlFor="password">
              Password
              <input
                id="password"
                type="password"
                placeholder="••••••••"
                value={password}
                onChange={(event) => setPassword(event.target.value)}
                required
              />
            </label>
            {error ? <div className="error-message">{error}</div> : null}
            <button type="submit" disabled={isLoading}>
              {isLoading ? 'Signing in…' : 'Sign in'}
            </button>
          </form>
        );
      };

      const LoginSelection = ({ onSelectInsights, onSelectMobility }) => {
        return (
          <div className="login-options">
            <button
              type="button"
              className="login-option-btn"
              onClick={onSelectInsights}
            >
              Login to Spirits Insights
            </button>
            <button
              type="button"
              className="login-option-btn"
              onClick={onSelectMobility}
            >
              Login to Spirits Mobility
            </button>
          </div>
        );
      };

      const MobilityConnectionForm = ({ onConnect, onBack, isLoading, error }) => {
        const [serverIp, setServerIp] = useState(() => {
          const saved = localStorage.getItem('spirits_mobility_ip');
          return saved || '';
        });
        const [serverPort, setServerPort] = useState(() => {
          const saved = localStorage.getItem('spirits_mobility_port');
          return saved || '8080';
        });

        const handleConnect = (event) => {
          event.preventDefault();
          if (serverIp && serverPort) {
            // Save to localStorage
            localStorage.setItem('spirits_mobility_ip', serverIp);
            localStorage.setItem('spirits_mobility_port', serverPort);
            onConnect(serverIp, serverPort);
          }
        };

        return (
          <form onSubmit={handleConnect} className="mobility-form">
            <label htmlFor="server-ip">
              Server IP Address
              <input
                id="server-ip"
                type="text"
                placeholder="192.168.1.100"
                value={serverIp}
                onChange={(event) => setServerIp(event.target.value)}
                required
                pattern="^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$|^[a-zA-Z0-9]([a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?(\\.[a-zA-Z0-9]([a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?)*$"
                title="Enter a valid IP address or hostname"
              />
            </label>
            <div className="mobility-form-row">
              <label htmlFor="server-port">
                Port
                <input
                  id="server-port"
                  type="number"
                  placeholder="8080"
                  value={serverPort}
                  onChange={(event) => setServerPort(event.target.value)}
                  required
                  min="1"
                  max="65535"
                />
              </label>
            </div>
            {error ? <div className="error-message">{error}</div> : null}
            <div className="mobility-actions">
              <button type="button" className="secondary" onClick={onBack} disabled={isLoading}>
                Back
              </button>
              <button type="submit" className="primary" disabled={isLoading || !serverIp || !serverPort}>
                {isLoading ? 'Connecting…' : 'Connect'}
              </button>
            </div>
          </form>
        );
      };


      const SalesModule = ({
  summary,
  sales,
  topItems,
  breakdowns,
  syncLogs,
  storeLabel,
  onRefresh,
        isLoading,
        dateRange,
        onDateRangeChange,
}) => {
  const derivedSummary = useMemo(() => {
    const fallback = sales.reduce(
      (acc, day) => {
        acc.sales += toNumber(day.total_sales, 0);
        acc.items += toNumber(day.total_items_sold, 0);
        return acc;
      },
      { sales: 0, items: 0 }
    );
    const fallbackDays = sales.length;
    const base = summary || {};
    const grossSales = toNumber(base.gross_sales, fallback.sales);
    const totalItems = toNumber(base.total_items, fallback.items);
    const rawDays =
      base.days_captured !== undefined && base.days_captured !== null
        ? toNumber(base.days_captured, fallbackDays)
        : fallbackDays;
    const safeDays = rawDays > 0 ? rawDays : fallbackDays;
    const averageDollarsPerSale =
      base.average_dollars_per_sale !== undefined && base.average_dollars_per_sale !== null
        ? toNumber(base.average_dollars_per_sale, 0)
        : 0;
    // Total net amount is the sum of all payment methods (tenders) net amounts
    // This is calculated from the payment_methods in the backend
    const totalNet = base.total_net !== undefined && base.total_net !== null
      ? toNumber(base.total_net, 0)
      : grossSales; // Fallback to grossSales if total_net not available

    const totalEcommerce = base.total_ecommerce_sales !== undefined && base.total_ecommerce_sales !== null
      ? toNumber(base.total_ecommerce_sales, 0)
      : 0;
    const totalInStore = base.total_in_store_sales !== undefined && base.total_in_store_sales !== null
      ? toNumber(base.total_in_store_sales, 0)
      : totalNet - totalEcommerce; // Fallback calculation if not provided

    return {
      grossSales,
      totalItems,
      daysCaptured: rawDays,
      averageDollarsPerSale,
      totalNet,
      totalEcommerce,
      totalInStore,
    };
  }, [sales, summary]);

  const topDay = useMemo(() => {
    if (!sales?.length) return null;
    const ranked = [...sales].sort(
      (a, b) => toNumber(b.total_sales, 0) - toNumber(a.total_sales, 0)
    );
    const winner = ranked[0];
    if (!winner) return null;
    return {
      date: winner.date,
      totalSales: toNumber(winner.total_sales, 0),
      items: toNumber(winner.total_items_sold, 0),
    };
  }, [sales]);

  const computedRange = useMemo(() => {
    if (!sales?.length) return null;
    const range = sales.reduce(
      (acc, entry) => {
        const value = entry.date;
        if (!value) {
          return acc;
        }
        const isoLike = typeof value === 'string' && !value.includes('T') ? `${value}T00:00:00` : value;
        const parsed = new Date(isoLike);
        if (Number.isNaN(parsed.getTime())) {
          return acc;
        }
        if (!acc.start || parsed < acc.start) {
          acc.start = parsed;
        }
        if (!acc.end || parsed > acc.end) {
          acc.end = parsed;
        }
        return acc;
      },
      { start: null, end: null }
    );
    if (!range.start || !range.end) {
      return null;
    }
    return range;
  }, [sales]);

  const displayRange = useMemo(() => {
    if (dateRange?.start && dateRange?.end) {
      const start = new Date(`${dateRange.start}T00:00:00`);
      const end = new Date(`${dateRange.end}T00:00:00`);
      if (!Number.isNaN(start.getTime()) && !Number.isNaN(end.getTime())) {
        return { start, end };
      }
    }
    return computedRange;
  }, [dateRange, computedRange]);

  const [view, setView] = useState('hourly');
  const hourly = breakdowns?.hourly || [];
  const payment = breakdowns?.payment || breakdowns?.payment_methods || [];
  const categories = breakdowns?.categories || [];

  const viewMeta = {
    hourly: {
      label: 'Hour',
      title: 'Sales by Hour',
      chart: <HourlySalesChart data={hourly} />,
      legend: null,
      hasLegend: false,
    },
    payment: {
      label: 'Payment',
      title: 'Sales by Payment Type',
      chart: <BreakdownPieChart data={payment} labelKey="method" />,
      legend: payment.length ? <BreakdownLegend items={payment} labelKey="method" /> : null,
      hasLegend: payment.length > 0,
    },
    category: {
      label: 'Category',
      title: 'Sales by Category',
      chart: <BreakdownPieChart data={categories} labelKey="category" />,
      legend: categories.length ? <BreakdownLegend items={categories} labelKey="category" /> : null,
      hasLegend: categories.length > 0,
    },
  };

  const viewOrder = ['hourly', 'payment', 'category'];
  const activeMeta = viewMeta[view] || viewMeta.hourly;

  const displayedTopItems = useMemo(() => {
    if (!topItems?.length) return [];
    return topItems.slice(0, 8);
  }, [topItems]);

  return (
    <div className="panel sales-panel">
      <div className="sales-hero">
        <div className="sales-hero-left">
          <div className="hero-icon">📈</div>
          <div className="hero-copy">
            <span className="hero-eyebrow">{`Sales · ${activeMeta.label}`}</span>
            <h2 className="hero-title">{storeLabel || 'Store Insights'}</h2>
            <div className="hero-dates">
              {displayRange ? (
                <>
                  <span>{formatDate(displayRange.start)}</span>
                  <span className="hero-divider">to</span>
                  <span>{formatDate(displayRange.end)}</span>
                </>
              ) : (
                <span className="hero-subtitle">Waiting for recent activity</span>
              )}
            </div>
          </div>
        </div>
        <div className="sales-hero-metric">
          <span>Total Net Amount</span>
          <strong>{formatCurrency(derivedSummary.totalNet)}</strong>
          <span>
            {derivedSummary.daysCaptured
              ? `${derivedSummary.daysCaptured} day window`
              : 'No sales recorded'}
          </span>
        </div>
      </div>

      <div className="sales-chart-card">
        <div className="sales-chart-header">
          <div>
            <h3>{activeMeta.title}</h3>
            <p className="chart-subtitle">
              {dateRange?.start && dateRange?.end
                ? `${formatDate(dateRange.start)} to ${formatDate(dateRange.end)}`
                : 'Selected range'}
            </p>
          </div>
          <div className="inline-actions">
            <input
              type="date"
              value={dateRange?.start || ''}
              onChange={(e) => onDateRangeChange({ ...(dateRange || {}), start: e.target.value })}
              onBlur={(e) => {
                // Ensure end date is set when user finishes typing start date
                if (e.target.value) {
                  const newRange = { ...(dateRange || {}), start: e.target.value };
                  if (!dateRange?.end || dateRange.end === dateRange.start) {
                    onDateRangeChange({ ...newRange, end: e.target.value });
                  } else {
                    onDateRangeChange(newRange);
                  }
                }
              }}
            />
            <input
              type="date"
              value={dateRange?.end || ''}
              onChange={(e) => onDateRangeChange({ ...(dateRange || {}), end: e.target.value })}
            />
            <button type="button" className="secondary" onClick={onRefresh} disabled={isLoading}>
              {isLoading ? (
                <>
                  <span className="spinner"></span>
                  Refreshing…
                </>
              ) : (
                'Refresh'
              )}
            </button>
          </div>
        </div>
        <div className={`sales-chart-grid${activeMeta.hasLegend ? ' with-legend' : ''}`}>
          <div className="chart-area" style={{ position: 'relative' }}>
            {activeMeta.chart}
            {isLoading && (
              <div className="loading-overlay">
                <span className="spinner"></span>
              </div>
            )}
          </div>
          {activeMeta.hasLegend ? activeMeta.legend : null}
        </div>
        <div className="sales-view-tabs">
          {viewOrder.map((key) => {
            const meta = viewMeta[key];
            return (
              <button
                key={key}
                type="button"
                className={view === key ? 'active' : ''}
                onClick={() => setView(key)}
              >
                {meta.label}
              </button>
            );
          })}
        </div>
      </div>

      <div className="summary-grid">
        <div className="summary-card">
          <h3>Average Dollars Per Sale</h3>
          <strong>{formatCurrency(derivedSummary.averageDollarsPerSale)}</strong>
          <span>
            {derivedSummary.daysCaptured
              ? `Average transaction value over ${derivedSummary.daysCaptured} day${derivedSummary.daysCaptured !== 1 ? 's' : ''}`
              : 'No sales data'}
          </span>
        </div>
        <div className="summary-card">
          <h3>Total Items Sold</h3>
          <strong>{formatQuantity(derivedSummary.totalItems)}</strong>
          <span>Across all recorded sales</span>
        </div>
        <div className="summary-card">
          <h3>Strongest Day</h3>
          <strong>{topDay ? formatDate(topDay.date) : '—'}</strong>
          <span>
            {topDay ? `${formatCurrency(topDay.totalSales)} in sales` : 'Waiting for activity'}
          </span>
        </div>
        {derivedSummary.totalEcommerce > 0 && (
          <>
            <div className="summary-card">
              <h3>Ecommerce Sales</h3>
              <strong>{formatCurrency(derivedSummary.totalEcommerce)}</strong>
              <span>Online/Web orders</span>
            </div>
            <div className="summary-card">
              <h3>In-Store Sales</h3>
              <strong>{formatCurrency(derivedSummary.totalInStore)}</strong>
              <span>Physical store transactions</span>
            </div>
          </>
        )}
      </div>

      <div className="insight-grid two-column">
        <div className="table-card">
          <h3>Top Products</h3>
          <p className="chart-subtitle">
            {displayRange ? `${formatDate(displayRange.start)} to ${formatDate(displayRange.end)}` : ''}
          </p>
          {displayedTopItems.length ? (
            <div className="table-wrapper">
              <table>
                <thead>
                  <tr>
                    <th>#</th>
                    <th>SKU</th>
                    <th>Product</th>
                    <th>Size</th>
                    <th>Items</th>
                    <th>Sales</th>
                  </tr>
                </thead>
                <tbody>
                  {displayedTopItems.map((item, index) => (
                    <tr key={`${item.sku}-${index}`}>
                      <td>{index + 1}</td>
                      <td>{item.sku || '—'}</td>
                      <td>{item.description || '—'}</td>
                      <td>{item.size_name || '—'}</td>
                      <td>{formatQuantity(item.total_items_sold)}</td>
                      <td>{formatCurrency(item.total_sales)}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          ) : (
            <div className="empty-state">No product performance available for this window.</div>
          )}
        </div>

        <div className="chart-card">
          <div className="chart-header">
            <h3>Trend</h3>
            <p className="chart-subtitle">
              {displayRange ? `${formatDate(displayRange.start)} to ${formatDate(displayRange.end)}` : ''}
            </p>
          </div>
          <div className="chart-area">
            <SalesChart sales={sales} />
          </div>
          {topDay ? (
            <div className="metric-note">
              <strong>{formatDate(topDay.date)}</strong> was the strongest day with {formatCurrency(topDay.totalSales)}{' '}
              across {formatQuantity(topDay.items)} items.
            </div>
          ) : null}
        </div>
      </div>

      <div className="insight-grid two-column">
        <div className="table-card">
          <h3>Daily Sales</h3>
          {sales.length ? (
            <div className="table-wrapper">
              <table>
                <thead>
                  <tr>
                    <th>Date</th>
                    <th>Items Sold</th>
                    <th>Total Sales</th>
                  </tr>
                </thead>
                <tbody>
                  {sales.map((sale) => (
                    <tr key={sale.date}>
                      <td>{formatDate(sale.date)}</td>
                      <td>{formatQuantity(sale.total_items_sold)}</td>
                      <td>{formatCurrency(sale.total_sales)}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          ) : (
            <div className="empty-state">No sales recorded in the last 7 days.</div>
          )}
        </div>

      </div>
    </div>
  );
};

const PurchaseOrdersModule = ({ orders, dateRange, onDateRangeChange }) => {
  const [modalOpen, setModalOpen] = useState(false);
  const [selectedVendor, setSelectedVendor] = useState(null);

  const openVendorModal = (order) => {
    setSelectedVendor(order);
    setModalOpen(true);
  };

  const closeModal = () => {
    setModalOpen(false);
    setSelectedVendor(null);
  };

  return (
    <div className="panel">
      <div className="panel-header">
        <div>
          <h2 className="panel-title">Purchase Orders</h2>
          <p className="chart-subtitle">
            {dateRange?.start && dateRange?.end
              ? `${formatDate(dateRange.start)} to ${formatDate(dateRange.end)}`
              : 'Selected range'}
          </p>
        </div>
        <div className="inline-actions">
          <input
            type="date"
            value={dateRange?.start || ''}
            onChange={(e) => onDateRangeChange({ ...(dateRange || {}), start: e.target.value })}
            onBlur={(e) => {
              // Ensure end date is set when user finishes typing start date
              if (e.target.value) {
                const newRange = { ...(dateRange || {}), start: e.target.value };
                if (!dateRange?.end || dateRange.end === dateRange.start) {
                  onDateRangeChange({ ...newRange, end: e.target.value });
                } else {
                  onDateRangeChange(newRange);
                }
              }
            }}
          />
          <input
            type="date"
            value={dateRange?.end || ''}
            onChange={(e) => onDateRangeChange({ ...(dateRange || {}), end: e.target.value })}
          />
        </div>
      </div>
      {orders?.length ? (
        <div className="table-wrapper">
          <table>
            <thead>
              <tr>
                <th>Vendor</th>
                <th>Status</th>
                <th>Orders</th>
                <th>Total</th>
              </tr>
            </thead>
            <tbody>
              {orders.map((order, idx) => {
                const vendorKey = `${order.vendor_num || idx}-${order.status}`;
                return (
                  <tr key={vendorKey}>
                    <td>{order.vendor_name || `Vendor #${order.vendor_num || '—'}`}</td>
                    <td>{order.status || '—'}</td>
                    <td>{order.order_count || 0}</td>
                    <td>
                      <button
                        type="button"
                        onClick={() => openVendorModal(order)}
                        style={{
                          background: 'none',
                          border: 'none',
                          color: 'inherit',
                          cursor: 'pointer',
                          textDecoration: 'underline',
                          padding: 0,
                          font: 'inherit',
                        }}
                      >
                        {formatCurrency(order.po_total || 0)}
                      </button>
                    </td>
                  </tr>
                );
              })}
            </tbody>
          </table>
        </div>
      ) : (
        <div className="empty-state">No orders found for the selected date range.</div>
      )}
      {modalOpen && selectedVendor && (
        <div className="modal-overlay" onClick={closeModal}>
          <div className="modal-content" onClick={(e) => e.stopPropagation()}>
            <div className="modal-header">
              <h3>Vendor Order Summary</h3>
              <button type="button" className="modal-close" onClick={closeModal} aria-label="Close">
                ×
              </button>
            </div>
            <div className="modal-body">
              <div style={{ marginBottom: '1.5rem' }}>
                <p><strong>Vendor:</strong> {selectedVendor.vendor_name || `Vendor #${selectedVendor.vendor_num || '—'}`}</p>
                <p><strong>Status:</strong> {selectedVendor.status || '—'}</p>
                <p><strong>Total Orders:</strong> {selectedVendor.order_count || 0}</p>
                <p><strong>Total Amount:</strong> {formatCurrency(selectedVendor.po_total || 0)}</p>
              </div>
              {selectedVendor.orders?.length > 0 ? (
                <div>
                  <h4 style={{ marginBottom: '1rem', fontSize: '1rem', fontWeight: 600 }}>Order Details:</h4>
                  <table style={{ width: '100%', fontSize: '0.9rem' }}>
                    <thead>
                      <tr>
                        <th style={{ textAlign: 'left', padding: '0.5rem' }}>PO ID</th>
                        <th style={{ textAlign: 'left', padding: '0.5rem' }}>Date</th>
                        <th style={{ textAlign: 'right', padding: '0.5rem' }}>Total</th>
                      </tr>
                    </thead>
                    <tbody>
                      {selectedVendor.orders.map((po, poIdx) => (
                        <tr key={`${po.po_id}-${poIdx}`}>
                          <td style={{ padding: '0.5rem' }}>{po.po_id || '—'}</td>
                          <td style={{ padding: '0.5rem' }}>{po.order_date ? formatDate(po.order_date) : '—'}</td>
                          <td style={{ padding: '0.5rem', textAlign: 'right' }}>{formatCurrency(po.order_total || 0)}</td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              ) : (
                <p>No order details available.</p>
              )}
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

const InventoryModule = ({ snapshot, dateRange, onDateRangeChange }) => {
  const segments = snapshot?.segments || [];
  return (
    <div className="panel">
      <div className="panel-header">
        <h2 className="panel-title">Inventory Value</h2>
        <div className="inline-actions">
          <input
            type="date"
            value={dateRange?.start || ''}
            onChange={(e) => onDateRangeChange({ ...(dateRange || {}), start: e.target.value })}
          />
          <input
            type="date"
            value={dateRange?.end || ''}
            onChange={(e) => onDateRangeChange({ ...(dateRange || {}), end: e.target.value })}
          />
        </div>
      </div>
      <div className="summary-grid">
        <div className="summary-card">
          <h3>Total Value</h3>
          <strong>{formatCurrency(snapshot?.total_value || 0)}</strong>
          <span>{segments.length ? 'Breakdown by category' : 'Connect inventory feeds to populate this view'}</span>
        </div>
      </div>
      <div className="chart-card">
        <div className="chart-header">
          <h3>Inventory Segments</h3>
        </div>
        <div className="chart-area">
          {segments.length ? (
            <BreakdownPieChart data={segments} labelKey="label" />
          ) : (
            <div className="empty-state">No inventory data available.</div>
          )}
        </div>
        {segments.length ? <BreakdownLegend items={segments} labelKey="label" /> : null}
      </div>
    </div>
  );
};

const fetchProductHistory = async (authToken, storeQuery, searchQuery, signal) => {
  // Check cache first - cache key includes search query
  const cacheKey = `product_history_${storeQuery}_${searchQuery || 'all'}`;
  const cached = getCachedData(cacheKey, STORAGE_KEYS.salesCache, 15); // 15 min cache for product history
  if (cached) {
    return cached;
  }

  const searchParam = searchQuery ? `&search=${encodeURIComponent(searchQuery)}` : '';
  const response = await fetch(`${API_BASE}/insights/product-history${storeQuery}${searchParam}`, {
    headers: { Authorization: `Bearer ${authToken}` },
    signal,
  });
  let payload = {};
  try {
    payload = await response.json();
  } catch (error) {
    payload = {};
  }
  if (!response.ok) {
    const requestError = new Error(payload.detail || 'Unable to load product history');
    requestError.status = response.status;
    throw requestError;
  }
  
  // Cache the result
  setCachedData(cacheKey, STORAGE_KEYS.salesCache, payload);
  
  return payload;
};

const HistoryModule = ({ token, storeQueryValue }) => {
  const [query, setQuery] = useState('');
  const [products, setProducts] = useState([]);
  const [selectedProduct, setSelectedProduct] = useState(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState('');
  const [isMobile, setIsMobile] = useState(window.innerWidth <= 768);
  const debounceRef = useRef(null);

  // Track window size for mobile detection
  useEffect(() => {
    const handleResize = () => {
      setIsMobile(window.innerWidth <= 768);
    };
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  useEffect(() => {
    if (!token || !storeQueryValue) return;
    
    // Only search if query has at least 2 characters
    if (!query || query.trim().length < 2) {
      setProducts([]);
      setIsLoading(false);
      setError('');
      return;
    }

    // Debounce search to avoid too many API calls
    if (debounceRef.current) {
      clearTimeout(debounceRef.current);
    }

    setIsLoading(true);
    setError('');

    debounceRef.current = setTimeout(async () => {
      try {
        const controller = new AbortController();
        const payload = await fetchProductHistory(token, storeQueryValue, query, controller.signal);
        setProducts(payload.products || []);
        setIsLoading(false);
        // Clear selected product when new search results come in
        setSelectedProduct(null);
      } catch (err) {
        if (err.name !== 'AbortError') {
          setError(err.message || 'Unable to load product history');
          setIsLoading(false);
        }
      }
    }, 300);

    return () => {
      if (debounceRef.current) {
        clearTimeout(debounceRef.current);
      }
    };
  }, [token, storeQueryValue, query]);

  return (
    <div className="panel">
      <div className="panel-header">
        <h2 className="panel-title">Product Sales History</h2>
      </div>
      <div className="search-bar">
        <input
          type="text"
          value={query}
          onChange={(event) => setQuery(event.target.value)}
          placeholder="Enter SKU, scan/enter UPC, or type product name"
          autoFocus
        />
      </div>
      
      {!query || query.trim().length < 2 ? (
        <div className="empty-state" style={{ padding: '2rem', textAlign: 'center', color: 'var(--text-muted)' }}>
          <p style={{ fontSize: '1rem', margin: '0.5rem 0' }}>Enter a SKU, scan or enter a UPC, or type a name of a product</p>
          <p style={{ fontSize: '0.9rem', margin: '0.5rem 0' }}>Results will appear as you type</p>
        </div>
      ) : isLoading ? (
        <div className="empty-state">Loading product history...</div>
      ) : error ? (
        <div className="empty-state" style={{ color: 'var(--danger)' }}>{error}</div>
      ) : products.length ? (
        <div>
          {/* Product List - Brief Summary */}
          <div>
            <h3 style={{ margin: '0 0 1rem 0', fontSize: '1rem' }}>Products ({products.length})</h3>
            <div style={{ display: 'grid', gridTemplateColumns: isMobile ? '1fr' : 'repeat(auto-fill, minmax(280px, 1fr))', gap: '1rem' }}>
              {products.map((product, idx) => (
                <div
                  key={`product-${product.sku || idx}-${product.upc || idx}-${idx}`}
                  onClick={() => setSelectedProduct(product)}
                  style={{
                    padding: '1rem',
                    border: '1px solid var(--panel-border)',
                    borderRadius: '8px',
                    cursor: 'pointer',
                    backgroundColor: 'var(--panel-bg)',
                    transition: 'all 0.2s',
                    boxShadow: '0 1px 3px rgba(0,0,0,0.1)'
                  }}
                  onMouseEnter={(e) => {
                    e.currentTarget.style.backgroundColor = 'var(--panel-bg-hover)';
                    e.currentTarget.style.boxShadow = '0 4px 6px rgba(0,0,0,0.1)';
                  }}
                  onMouseLeave={(e) => {
                    e.currentTarget.style.backgroundColor = 'var(--panel-bg)';
                    e.currentTarget.style.boxShadow = '0 1px 3px rgba(0,0,0,0.1)';
                  }}
                >
                  <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', marginBottom: '0.5rem' }}>
                    <div style={{ fontWeight: '600', fontSize: '1rem', color: 'var(--text)' }}>
                      {product.name || '—'}
                    </div>
                    {product.store_num && (
                      <div style={{ 
                        fontSize: '0.75rem', 
                        fontWeight: '600',
                        color: 'var(--primary)',
                        backgroundColor: 'var(--primary-soft)',
                        padding: '0.25rem 0.5rem',
                        borderRadius: '4px'
                      }}>
                        Store #{product.store_num}
                      </div>
                    )}
                  </div>
                  <div style={{ fontSize: '0.85rem', color: 'var(--text-muted)', display: 'flex', flexDirection: 'column', gap: '0.25rem' }}>
                    <div><strong>SKU:</strong> {product.sku || '—'}</div>
                    {product.upc && <div><strong>UPC:</strong> {product.upc}</div>}
                    <div style={{ display: 'flex', gap: '1rem', marginTop: '0.5rem', flexWrap: 'wrap' }}>
                      <div><strong>Price:</strong> {formatCurrency(product.price || 0)}</div>
                      <div><strong>Cost:</strong> {formatCurrency(product.cost || 0)}</div>
                    </div>
                    {product.stock_qty !== null && product.stock_qty !== undefined && (
                      <div style={{ marginTop: '0.5rem' }}>
                        <strong>Stock:</strong> {formatQuantity(product.stock_qty)}
                        {product.stock_floor !== null && product.stock_floor !== undefined && product.stock_floor !== 0 && (
                          <span> | <strong>Floor:</strong> {formatQuantity(product.stock_floor)}</span>
                        )}
                        {product.stock_kit !== null && product.stock_kit !== undefined && product.stock_kit !== 0 && (
                          <span> | <strong>Kit:</strong> {formatQuantity(product.stock_kit)}</span>
                        )}
                      </div>
                    )}
                    <div style={{ marginTop: '0.5rem', fontSize: '0.8rem', color: 'var(--primary)', fontWeight: '500' }}>
                      Click to view details →
                    </div>
                  </div>
                </div>
              ))}
            </div>
          </div>

          {/* Modal for Product Details */}
          {selectedProduct && (
            <div className="modal-overlay" onClick={() => setSelectedProduct(null)}>
              <div className="modal-content" onClick={(e) => e.stopPropagation()} style={{ maxWidth: isMobile ? '95%' : '900px', maxHeight: '90vh', overflowY: 'auto' }}>
                <div className="modal-header">
                  <h3>{selectedProduct.name || 'Product Details'}</h3>
                  <button className="modal-close" onClick={() => setSelectedProduct(null)}>×</button>
                </div>
                <div style={{ padding: '1.5rem' }}>
                  {/* Product Information */}
                  <div style={{ marginBottom: '2rem', paddingBottom: '1.5rem', borderBottom: '1px solid var(--panel-border)' }}>
                    <div style={{ display: 'grid', gridTemplateColumns: isMobile ? '1fr' : 'repeat(2, 1fr)', gap: '1rem', fontSize: '0.9rem' }}>
                      <div><strong>SKU:</strong> {selectedProduct.sku || '—'}</div>
                      {selectedProduct.upc && <div><strong>UPC:</strong> {selectedProduct.upc}</div>}
                      <div><strong>Price:</strong> {formatCurrency(selectedProduct.price || 0)}</div>
                      <div><strong>Cost:</strong> {formatCurrency(selectedProduct.cost || 0)}</div>
                      {selectedProduct.store_num && (
                        <div><strong>Store #:</strong> {selectedProduct.store_num}</div>
                      )}
                      {selectedProduct.stock_qty !== null && selectedProduct.stock_qty !== undefined && (
                        <div><strong>Stock Qty:</strong> {formatQuantity(selectedProduct.stock_qty)}</div>
                      )}
                      {selectedProduct.stock_floor !== null && selectedProduct.stock_floor !== undefined && (
                        <div><strong>Floor:</strong> {formatQuantity(selectedProduct.stock_floor)}</div>
                      )}
                      {selectedProduct.stock_kit !== null && selectedProduct.stock_kit !== undefined && (
                        <div><strong>Kit:</strong> {formatQuantity(selectedProduct.stock_kit)}</div>
                      )}
                    </div>
                  </div>

                  {/* Purchase Orders and Sales */}
                  <div style={{ display: 'grid', gridTemplateColumns: isMobile ? '1fr' : '1fr 1fr', gap: '1.5rem' }}>
                    {/* Last 5 Purchase Orders */}
                    <div>
                      <h4 style={{ margin: '0 0 1rem 0', fontSize: '1rem', fontWeight: '600' }}>Last 5 Purchase Orders</h4>
                      {selectedProduct.purchase_orders?.length > 0 ? (
                        <div className="table-wrapper" style={{ overflowX: 'auto' }}>
                          <table style={{ fontSize: '0.9rem', width: '100%' }}>
                            <thead>
                              <tr>
                                <th>Order #</th>
                                <th>SKU</th>
                                <th>Name</th>
                                <th>Size</th>
                                <th>Qty</th>
                                <th>Date</th>
                              </tr>
                            </thead>
                            <tbody>
                              {selectedProduct.purchase_orders.map((po, idx) => (
                                <tr key={`po-${po.po_id || idx}-${idx}`}>
                                  <td>{po.po_id || '—'}</td>
                                  <td>{po.sku || '—'}</td>
                                  <td>{po.name || '—'}</td>
                                  <td>{po.sname || '—'}</td>
                                  <td>{formatQuantity(po.oqty || 0)}</td>
                                  <td>{po.date || '—'}</td>
                                </tr>
                              ))}
                            </tbody>
                          </table>
                        </div>
                      ) : (
                        <div className="empty-state" style={{ padding: '1rem', fontSize: '0.9rem' }}>No purchase orders found</div>
                      )}
                    </div>

                    {/* Last 5 Sales */}
                    <div>
                      <h4 style={{ margin: '0 0 1rem 0', fontSize: '1rem', fontWeight: '600' }}>Last 5 Sales</h4>
                      {selectedProduct.recent_sales?.length > 0 ? (
                        <div className="table-wrapper" style={{ overflowX: 'auto' }}>
                          <table style={{ fontSize: '0.9rem', width: '100%' }}>
                            <thead>
                              <tr>
                                <th>Sale ID</th>
                                <th>Date</th>
                                <th>Qty</th>
                                <th>Amount</th>
                              </tr>
                            </thead>
                            <tbody>
                              {selectedProduct.recent_sales.map((sale, idx) => (
                                <tr key={`sale-${sale.sale_id || idx}-${idx}`}>
                                  <td>{sale.sale_id || '—'}</td>
                                  <td>{sale.date || '—'}</td>
                                  <td>{formatQuantity(sale.qty || 0)}</td>
                                  <td>{formatCurrency(sale.amount || 0)}</td>
                                </tr>
                              ))}
                            </tbody>
                          </table>
                        </div>
                      ) : (
                        <div className="empty-state" style={{ padding: '1rem', fontSize: '0.9rem' }}>No sales found</div>
                      )}
                    </div>
                  </div>
                </div>
              </div>
            </div>
          )}
        </div>
      ) : (
        <div className="empty-state">
          No products found matching your search.
        </div>
      )}
    </div>
  );
};

const TendersModule = ({ data, gatewayData, dateRange, onDateRangeChange }) => {
  if (!data) {
    return <div className="empty-state">Loading payment methods data...</div>;
  }

  const tenders = data.tenders || [];
  const dailyTrends = data.daily_trends || [];
  const creditCards = gatewayData?.credit_cards || [];
  const gatewaySummary = gatewayData?.summary || {};

  return (
    <div>
      <div className="panel">
        <div className="panel-header">
          <h2 className="panel-title">Payment Methods</h2>
        </div>
        {tenders.length ? (
          <div className="table-wrapper">
            <table>
              <thead>
                <tr>
                  <th>Payment Type</th>
                  <th>Sale Amount</th>
                  <th>Sale Count</th>
                  <th>Reversal Amount</th>
                  <th>Reversal Count</th>
                  <th>Net Amount</th>
                </tr>
              </thead>
              <tbody>
                {tenders.map((tender, idx) => (
                  <tr key={idx}>
                    <td>{tender.payment_type}</td>
                    <td>{formatCurrency(tender.sale_amount)}</td>
                    <td>{tender.sale_count}</td>
                    <td>{formatCurrency(tender.reversal_amount)}</td>
                    <td>{tender.reversal_count}</td>
                    <td><strong>{formatCurrency(tender.net_amount)}</strong></td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        ) : (
          <div className="empty-state">No payment method data available.</div>
        )}
      </div>

      {creditCards.length > 0 && (
        <div className="panel" style={{ marginTop: '1.5rem' }}>
          <div className="panel-header">
            <h2 className="panel-title">Credit Card & Ecommerce Breakdown</h2>
          </div>
          <div className="summary-grid">
            <div className="summary-card">
              <h3>Total Credit Card Sales</h3>
              <strong>{formatCurrency(gatewaySummary.total_credit_card_sales || 0)}</strong>
            </div>
            <div className="summary-card">
              <h3>Ecommerce Sales</h3>
              <strong>{formatCurrency(gatewaySummary.total_ecommerce_sales || 0)}</strong>
            </div>
            <div className="summary-card">
              <h3>Combined Total</h3>
              <strong>{formatCurrency(gatewaySummary.total_combined || 0)}</strong>
            </div>
          </div>
          <div className="table-wrapper" style={{ marginTop: '1.5rem' }}>
            <table>
              <thead>
                <tr>
                  <th>Tender Type</th>
                  <th>In-Store Sales</th>
                  <th>Ecommerce Sales</th>
                  <th>Total Sales</th>
                </tr>
              </thead>
              <tbody>
                {creditCards.map((cc, idx) => (
                  <tr key={idx}>
                    <td>{cc.tender_type}</td>
                    <td>{formatCurrency(cc.in_store_sales)}</td>
                    <td>{formatCurrency(cc.ecommerce_sales)}</td>
                    <td><strong>{formatCurrency(cc.total_sales)}</strong></td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </div>
      )}
    </div>
  );
};

const GatewayModule = ({ data, dateRange, onDateRangeChange }) => {
  if (!data) {
    return <div className="empty-state">Loading credit card data...</div>;
  }

  const creditCards = data.credit_cards || [];
  const summary = data.summary || {};

  return (
    <div className="panel">
      <div className="panel-header">
        <h2 className="panel-title">Credit Card & Gateway Analytics</h2>
      </div>
      <div className="summary-grid">
        <div className="summary-card">
          <h3>Total Credit Card Sales</h3>
          <strong>{formatCurrency(summary.total_credit_card_sales || 0)}</strong>
        </div>
        <div className="summary-card">
          <h3>Ecommerce Sales</h3>
          <strong>{formatCurrency(summary.total_ecommerce_sales || 0)}</strong>
        </div>
        <div className="summary-card">
          <h3>Combined Total</h3>
          <strong>{formatCurrency(summary.total_combined || 0)}</strong>
        </div>
      </div>
      {creditCards.length ? (
        <div className="table-wrapper">
          <table>
            <thead>
              <tr>
                <th>Tender Type</th>
                <th>In-Store Sales</th>
                <th>Ecommerce Sales</th>
                <th>Total Sales</th>
              </tr>
            </thead>
            <tbody>
              {creditCards.map((cc, idx) => (
                <tr key={idx}>
                  <td>{cc.tender_type}</td>
                  <td>{formatCurrency(cc.in_store_sales)}</td>
                  <td>{formatCurrency(cc.ecommerce_sales)}</td>
                  <td><strong>{formatCurrency(cc.total_sales)}</strong></td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      ) : (
        <div className="empty-state">No credit card data available.</div>
      )}
    </div>
  );
};

const OperationsModule = ({ data }) => {
  if (!data) {
    return <div className="empty-state">Loading operations data...</div>;
  }

  return (
    <div className="panel">
      <div className="panel-header">
        <h2 className="panel-title">Store Operations</h2>
        <p className="chart-subtitle">Current month transactions • Overall products & invoices</p>
      </div>
      <div className="summary-grid">
        <div className="summary-card">
          <h3>Transaction Count</h3>
          <strong>{data.transaction_count || 0}</strong>
        </div>
        <div className="summary-card">
          <h3>Total Till</h3>
          <strong>{formatCurrency(data.total_till || 0)}</strong>
        </div>
        <div className="summary-card">
          <h3>Product Count</h3>
          <strong>{data.products?.count || 0}</strong>
        </div>
        <div className="summary-card">
          <h3>Supplier Invoices</h3>
          <strong>{data.supplier_invoices?.count || 0}</strong>
        </div>
      </div>
      <div className="insight-grid two-column">
        <div className="table-card">
          <h3>Gift Card Activity</h3>
          <div className="table-wrapper">
            <table>
              <thead>
                <tr>
                  <th>Type</th>
                  <th>Count</th>
                  <th>Amount</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Redemptions</td>
                  <td>{data.gift_cards?.redemptions?.count || 0}</td>
                  <td>{formatCurrency(data.gift_cards?.redemptions?.amount || 0)}</td>
                </tr>
                <tr>
                  <td>Purchases</td>
                  <td>{data.gift_cards?.purchases?.count || 0}</td>
                  <td>{formatCurrency(data.gift_cards?.purchases?.amount || 0)}</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
        <div className="table-card">
          <h3>Product Information</h3>
          <div className="table-wrapper">
            <table>
              <tbody>
                <tr>
                  <td>Total Products</td>
                  <td><strong>{data.products?.count || 0}</strong></td>
                </tr>
                <tr>
                  <td>First Created</td>
                  <td>{data.products?.first_created || 'N/A'}</td>
                </tr>
                <tr>
                  <td>Last Created</td>
                  <td>{data.products?.last_created || 'N/A'}</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>
      {data.supplier_invoices && (
        <div className="table-card">
          <h3>Supplier Invoice Information</h3>
          <div className="table-wrapper">
            <table>
              <tbody>
                <tr>
                  <td>Total Invoices</td>
                  <td><strong>{data.supplier_invoices.count || 0}</strong></td>
                </tr>
                <tr>
                  <td>First Date</td>
                  <td>{data.supplier_invoices.first_date || 'N/A'}</td>
                </tr>
                <tr>
                  <td>Last Date</td>
                  <td>{data.supplier_invoices.last_date || 'N/A'}</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      )}
    </div>
  );
};

const QuickViewWidget = ({ data }) => {
  if (!data) {
    return null;
  }

  return (
    <div className="panel" style={{ marginBottom: '1.5rem' }}>
      <div className="panel-header">
        <h2 className="panel-title">Quick View - {data.date}</h2>
      </div>
      <div className="summary-grid">
        <div className="summary-card">
          <h3>Today's Sales</h3>
          <strong>{formatCurrency(data.sales_summary?.total_sales || 0)}</strong>
          <span>{data.sales_summary?.transaction_count || 0} transactions</span>
        </div>
        <div className="summary-card">
          <h3>Gift Cards</h3>
          <strong>{data.gift_card_activity?.redemptions || 0} redemptions</strong>
          <span>{data.gift_card_activity?.purchases || 0} purchases</span>
        </div>
      </div>
      {data.top_items && data.top_items.length > 0 && (
        <div className="table-card">
          <h3>Top Items Today</h3>
          <div className="table-wrapper">
            <table>
              <thead>
                <tr>
                  <th>Item</th>
                  <th>Quantity</th>
                </tr>
              </thead>
              <tbody>
                {data.top_items.map((item, idx) => (
                  <tr key={idx}>
                    <td>{item.description || item.sku}</td>
                    <td>{formatQuantity(item.quantity)}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </div>
      )}
    </div>
  );
};

const ModuleNav = ({ active, onChange }) => {
  const modules = [
    { id: 'sales', label: 'Sales' },
    { id: 'purchase', label: 'Purchase Orders' },
    { id: 'inventory', label: 'Inventory' },
    { id: 'history', label: 'Sales History' },
    { id: 'tenders', label: 'Payment Methods' },
    { id: 'operations', label: 'Operations' },
  ];

  return (
    <nav className="module-nav">
      {modules.map((module) => (
        <button
          key={module.id}
          type="button"
          className={active === module.id ? 'active' : ''}
          onClick={() => onChange(module.id)}
        >
          {module.label}
        </button>
      ))}
      <select
        value={active}
        onChange={(e) => onChange(e.target.value)}
        aria-label="Select module"
      >
        {modules.map((module) => (
          <option key={module.id} value={module.id}>
            {module.label}
          </option>
        ))}
      </select>
    </nav>
  );
};

      const HeaderBar = ({ profile, stores, selectedStore, onStoreChange, onLogout }) => {
        const [profileMenuOpen, setProfileMenuOpen] = useState(false);
        const storeOptions = stores || [];
        const activeStore = selectedStore || storeOptions[0] || null;
        const greetingName = profile?.full_name || profile?.email || 'there';
        const storeLabel = activeStore
          ? activeStore.store_name || activeStore.store_db || `Store ${getStoreIdentifier(activeStore)}`
          : 'No store selected';

        // Close profile menu when clicking outside
        useEffect(() => {
          const handleClickOutside = (event) => {
            if (profileMenuOpen && !event.target.closest('.session-meta')) {
              setProfileMenuOpen(false);
            }
          };
          if (profileMenuOpen) {
            document.addEventListener('click', handleClickOutside);
            return () => document.removeEventListener('click', handleClickOutside);
          }
        }, [profileMenuOpen]);

        return (
          <header>
            <div className="header-bar">
              <div className="header-top">
                <div className="brand">
                  <div className="brand-icon">SI</div>
                  <h1>{storeLabel || 'Store Insights'}</h1>
                </div>
                <div className="session-meta">
                  <span 
                    className={`session-greeting ${profileMenuOpen ? 'open' : ''}`}
                    onClick={() => setProfileMenuOpen(!profileMenuOpen)}
                  >
                    Hello, {greetingName}
                  </span>
                  <WeatherCard compact={true} />
                  <div className={`profile-menu ${profileMenuOpen ? 'open' : ''}`}>
                    {storeOptions.length > 1 ? (
                      <div className="profile-menu-item store-select">
                        <label>
                          Select a store
                          <select
                            value={getStoreIdentifier(activeStore)}
                            onChange={(event) => {
                              const next = storeOptions.find(
                                (store) => getStoreIdentifier(store) === event.target.value
                              );
                              onStoreChange(next || storeOptions[0]);
                              setProfileMenuOpen(false);
                            }}
                          >
                            {storeOptions.map((store) => {
                              const identifier = getStoreIdentifier(store);
                              const label = store.store_name || store.store_db || `Store ${identifier}`;
                              return (
                                <option key={identifier} value={identifier}>
                                  {label}
                                </option>
                              );
                            })}
                          </select>
                        </label>
                      </div>
                    ) : (
                      <div className="profile-menu-item">
                        <div style={{ fontWeight: 600, marginBottom: '0.25rem' }}>Current Store</div>
                        <div style={{ fontSize: '0.9rem', color: 'var(--text-muted)' }}>{storeLabel}</div>
                      </div>
                    )}
                    <div 
                      className="profile-menu-item sign-out"
                      onClick={() => {
                        setProfileMenuOpen(false);
                        onLogout();
                      }}
                    >
                      Sign out
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </header>
        );
      };

      const Dashboard = ({
        stores,
        selectedStore,
        storeInfo,
        sales,
  summary,
  topItems,
  breakdowns,
  syncLogs,
  purchaseOrders,
  inventory,
  history,
  tendersData,
  gatewayData,
  operationsData,
  quickData,
  onStoreChange,
  onRefresh,
  activeModule,
  onModuleChange,
  loading,
  error,
        dateRange,
        onDateRangeChange,
        poRange,
        onPoRangeChange,
        invRange,
        onInvRangeChange,
        token,
        storeQueryValue,
}) => {
  const storeLabel = useMemo(() => {
    if (storeInfo?.store_name) return storeInfo.store_name;
    if (storeInfo?.store_db) return storeInfo.store_db;
    if (selectedStore?.store_name) return selectedStore.store_name;
    if (selectedStore?.store_db) return selectedStore.store_db;
    if (selectedStore?.store_id !== undefined && selectedStore?.store_id !== null) {
      return `Store #${selectedStore.store_id}`;
    }
    return '';
  }, [storeInfo, selectedStore]);

  return (
    <div className="app-main">
      <div className="app-main-inner">
        {/* Store selector now lives only in the header; duplicate removed */}

        {error ? (
          <div className="panel">
            <div className="panel-header">
              <h2 className="panel-title">Heads up</h2>
            </div>
            <div className="empty-state">{error}</div>
          </div>
        ) : null}

        {activeModule === 'sales' && quickData ? <QuickViewWidget data={quickData} /> : null}

        <ModuleNav active={activeModule} onChange={onModuleChange} />

        {activeModule === 'sales' ? (
          <SalesModule
            summary={summary}
            sales={sales}
            topItems={topItems}
            breakdowns={breakdowns}
            syncLogs={syncLogs}
            storeLabel={storeLabel}
            onRefresh={onRefresh}
            isLoading={loading}
            dateRange={dateRange}
            onDateRangeChange={onDateRangeChange}
          />
        ) : null}

        {activeModule === 'purchase' ? <PurchaseOrdersModule orders={purchaseOrders} dateRange={poRange} onDateRangeChange={onPoRangeChange} /> : null}

        {activeModule === 'inventory' ? <InventoryModule snapshot={inventory} dateRange={invRange} onDateRangeChange={onInvRangeChange} /> : null}

        {activeModule === 'history' ? <HistoryModule token={token} storeQueryValue={storeQueryValue} /> : null}

        {activeModule === 'tenders' ? <TendersModule data={tendersData} gatewayData={gatewayData} dateRange={dateRange} onDateRangeChange={onDateRangeChange} /> : null}

        {activeModule === 'operations' ? <OperationsModule data={operationsData} /> : null}
      </div>
    </div>
  );
};
      const App = () => {
        const [activeModule, setActiveModule] = useState('sales');
        const [token, setToken] = useState(() => storage.get(STORAGE_KEYS.token, null));
        const [userRole, setUserRole] = useState(() => storage.get(STORAGE_KEYS.role, ''));
        const [profile, setProfile] = useState(() => storage.get(STORAGE_KEYS.profile, null));
        const [stores, setStores] = useState(() => storage.get(STORAGE_KEYS.stores, []));
        const [selectedStore, setSelectedStore] = useState(() =>
          storage.get(STORAGE_KEYS.selectedStore, null)
        );
        const [sales, setSales] = useState([]);
        const [salesSummary, setSalesSummary] = useState(null);
        const [topItems, setTopItems] = useState([]);
        const [storeMeta, setStoreMeta] = useState(null);
        const [salesBreakdowns, setSalesBreakdowns] = useState({
          hourly: [],
          payment: [],
          payment_methods: [],
          categories: [],
        });
        const [purchaseOrders, setPurchaseOrders] = useState([]);
        const [inventorySnapshot, setInventorySnapshot] = useState(null);
        const [salesHistory, setSalesHistory] = useState([]);
        const [syncLogs, setSyncLogs] = useState([]);
        const [tendersData, setTendersData] = useState(null);
        const [gatewayData, setGatewayData] = useState(null);
        const [operationsData, setOperationsData] = useState(null);
        const [quickData, setQuickData] = useState(null);
        const [authError, setAuthError] = useState('');
        const [isAuthenticating, setIsAuthenticating] = useState(false);
        const [isLoadingData, setIsLoadingData] = useState(false);

        const todayYmd = () => {
          const d = new Date();
          const y = d.getFullYear();
          const m = String(d.getMonth() + 1).padStart(2, '0');
          const dd = String(d.getDate()).padStart(2, '0');
          return `${y}-${m}-${dd}`;
        };
        const [dateRange, setDateRange] = useState({ start: todayYmd(), end: todayYmd() });
        const [dateRangeEndManual, setDateRangeEndManual] = useState(false);
        const [poRange, setPoRange] = useState({ start: todayYmd(), end: todayYmd() });
        const [poRangeEndManual, setPoRangeEndManual] = useState(false);
        const [invRange, setInvRange] = useState({ start: '', end: '' });
        const [invRangeEndManual, setInvRangeEndManual] = useState(false);

        // Auto-set end date to start date when start changes (unless end was manually set)
        const handleDateRangeChange = useCallback((newRange) => {
          setDateRange((prev) => {
            // Clear cache when dates change to prevent showing stale data
            const startChanged = newRange.start !== undefined && newRange.start !== prev?.start;
            const endChanged = newRange.end !== undefined && newRange.end !== prev?.end;
            if (startChanged || endChanged) {
              clearSalesCache();
            }
            
            const updated = { ...(prev || {}), ...newRange };
            
            // If start changed and end wasn't manually set, update end to match start
            if (startChanged && !dateRangeEndManual) {
              updated.end = newRange.start;
              setDateRangeEndManual(false); // Reset manual flag when auto-updating
            }
            // If both dates match, reset manual flag (user might be resetting)
            if (updated.start && updated.end && updated.start === updated.end) {
              setDateRangeEndManual(false);
            }
            return updated;
          });
          // Track if end was manually changed (only if it's different from start)
          if (newRange.end !== undefined && newRange.end !== newRange.start) {
            setDateRangeEndManual(true);
          }
        }, [dateRangeEndManual]);

        const handlePoRangeChange = useCallback((newRange) => {
          setPoRange((prev) => {
            const updated = { ...(prev || {}), ...newRange };
            if (newRange.start && newRange.start !== prev?.start && !poRangeEndManual) {
              updated.end = newRange.start;
              setPoRangeEndManual(false);
            }
            if (updated.start && updated.end && updated.start === updated.end) {
              setPoRangeEndManual(false);
            }
            return updated;
          });
          if (newRange.end !== undefined && newRange.end !== newRange.start) {
            setPoRangeEndManual(true);
          }
        }, [poRangeEndManual]);

        const handleInvRangeChange = useCallback((newRange) => {
          setInvRange((prev) => {
            const updated = { ...(prev || {}), ...newRange };
            if (newRange.start && newRange.start !== prev?.start && !invRangeEndManual) {
              updated.end = newRange.start;
              setInvRangeEndManual(false);
            }
            if (updated.start && updated.end && updated.start === updated.end) {
              setInvRangeEndManual(false);
            }
            return updated;
          });
          if (newRange.end !== undefined && newRange.end !== newRange.start) {
            setInvRangeEndManual(true);
          }
        }, [invRangeEndManual]);

        const [adminKey, setAdminKey] = useState(() => storage.get(STORAGE_KEYS.adminKey, ''));
        const [adminUsers, setAdminUsers] = useState([]);
        const [selectedAdminUserId, setSelectedAdminUserId] = useState(null);
        const [adminError, setAdminError] = useState('');
        const [adminMessage, setAdminMessage] = useState('');
        const [isAdminLoading, setIsAdminLoading] = useState(false);
        const [isAdminProcessing, setIsAdminProcessing] = useState(false);

        const tokenRef = useRef(token);

        const storeQueryValue = useMemo(() => {
          const params = [];
          const identifier = getStoreIdentifier(selectedStore);
          if (identifier) params.push(`store=${encodeURIComponent(identifier)}`);
          if (dateRange?.start) params.push(`start=${encodeURIComponent(dateRange.start)}`);
          if (dateRange?.end) params.push(`end=${encodeURIComponent(dateRange.end)}`);
          if (poRange?.start) params.push(`po_start=${encodeURIComponent(poRange.start)}`);
          if (poRange?.end) params.push(`po_end=${encodeURIComponent(poRange.end)}`);
          if (invRange?.start) params.push(`inv_start=${encodeURIComponent(invRange.start)}`);
          if (invRange?.end) params.push(`inv_end=${encodeURIComponent(invRange.end)}`);
          return params.length ? `?${params.join('&')}` : '';
        }, [selectedStore, dateRange, poRange, invRange]);

        const storeQueryValueRef = useRef(storeQueryValue);

        const handleAdminLogout = useCallback(
          (message = '') => {
            setAdminKey('');
            storage.remove(STORAGE_KEYS.adminKey);
            setAdminUsers([]);
            setSelectedAdminUserId(null);
            setIsAdminLoading(false);
            setIsAdminProcessing(false);
            setAdminMessage('');
            setAdminError(message);
          },
          []
        );

        const handleLogout = useCallback(
          (message = '') => {
            storage.clearSession();
            setToken(null);
            setUserRole('');
            setProfile(null);
            setStores([]);
            setSelectedStore(null);
            setSales([]);
            setSalesSummary(null);
            setTopItems([]);
            setStoreMeta(null);
            setSalesBreakdowns({ hourly: [], payment: [], payment_methods: [], categories: [] });
            setPurchaseOrders([]);
            setInventorySnapshot(null);
            setSalesHistory([]);
            setSyncLogs([]);
            setTendersData(null);
            setGatewayData(null);
            setOperationsData(null);
            setQuickData(null);
            tokenRef.current = null;
            setAuthError(message);
            setIsAuthenticating(false);
            setIsLoadingData(false);
            setActiveModule('sales');
            handleAdminLogout('');
          },
          [handleAdminLogout]
        );

        useEffect(() => {
          tokenRef.current = token;
          if (token) {
            storage.set(STORAGE_KEYS.token, token);
          } else {
            storage.remove(STORAGE_KEYS.token);
          }
        }, [token]);

        useEffect(() => {
          if (profile && (profile.email || profile.full_name)) {
            storage.set(STORAGE_KEYS.profile, profile);
          } else {
            storage.remove(STORAGE_KEYS.profile);
          }
        }, [profile]);

        useEffect(() => {
          if (!token) {
            return;
          }

          const payload = decodeTokenPayload(token);
          if (!payload) {
            return;
          }

          if (!userRole && payload.role) {
            setUserRole(payload.role);
          }

          if (!profile?.email || (!profile?.full_name && payload.full_name)) {
            setProfile((prev) => {
              const next = prev ? { ...prev } : {};
              let changed = false;
              if (!next.email && payload.email) {
                next.email = payload.email;
                changed = true;
              }
              if (!next.full_name && payload.full_name) {
                next.full_name = payload.full_name;
                changed = true;
              }
              return changed ? next : prev;
            });
          }
        }, [token, userRole, profile]);

        useEffect(() => {
          if (userRole) {
            storage.set(STORAGE_KEYS.role, userRole);
          } else {
            storage.remove(STORAGE_KEYS.role);
          }
        }, [userRole]);

        useEffect(() => {
          if (stores?.length) {
            storage.set(STORAGE_KEYS.stores, stores);
          } else {
            storage.remove(STORAGE_KEYS.stores);
          }
        }, [stores]);

        useEffect(() => {
          if (!stores?.length) {
            if (selectedStore) {
              setSelectedStore(null);
            }
            return;
          }

          if (!selectedStore) {
            setSelectedStore(stores[0]);
            return;
          }

          const identifier = getStoreIdentifier(selectedStore);
          const match = stores.find((store) => getStoreIdentifier(store) === identifier);
          if (!match) {
            setSelectedStore(stores[0]);
          } else if (match !== selectedStore) {
            setSelectedStore(match);
          }
        }, [stores, selectedStore]);

        useEffect(() => {
          if (selectedStore) {
            storage.set(STORAGE_KEYS.selectedStore, selectedStore);
          } else {
            storage.remove(STORAGE_KEYS.selectedStore);
          }
        }, [selectedStore]);

        useEffect(() => {
          if (adminKey && userRole === 'admin') {
            storage.set(STORAGE_KEYS.adminKey, adminKey);
          } else {
            storage.remove(STORAGE_KEYS.adminKey);
          }
        }, [adminKey, userRole]);

        useEffect(() => {
          if (userRole !== 'admin' && adminKey) {
            handleAdminLogout();
          }
        }, [userRole, adminKey, handleAdminLogout]);

        const fetchSales = async (authToken, query, signal) => {
          // Check cache first
          const cacheKey = createCacheKey('sales', query);
          const cached = getCachedData(cacheKey, STORAGE_KEYS.salesCache, 10); // Increased to 10 min for better performance
          if (cached) {
            return cached;
          }

          const response = await fetch(`${API_BASE}/insights/sales${query}`, {
            headers: { Authorization: `Bearer ${authToken}` },
            signal,
          });
          let payload = {};
          try {
            payload = await response.json();
          } catch (error) {
            payload = {};
          }
          if (!response.ok) {
            const requestError = new Error(payload.detail || 'Unable to load sales data');
            requestError.status = response.status;
            throw requestError;
          }
          const result = {
            sales: payload.sales || [],
            summary: payload.summary || null,
            topItems: payload.top_items || [],
            store: payload.store || null,
            breakdowns: payload.breakdowns || {},
            purchaseOrders: payload.purchase_orders || [],
            inventory: payload.inventory || null,
            history: payload.sales_history || [],
          };
          
          // Cache the result
          setCachedData(cacheKey, STORAGE_KEYS.salesCache, result);
          
          return result;
        };

        const fetchSyncLogs = async (authToken, query, signal) => {
          // Check cache first - sync logs have shorter TTL (2 minutes) since they're status data
          const cacheKey = createCacheKey('sync', query);
          const cached = getCachedData(cacheKey, STORAGE_KEYS.syncCache, 2);
          if (cached) {
            return cached;
          }

          const response = await fetch(`${API_BASE}/sync/status${query}`, {
            headers: { Authorization: `Bearer ${authToken}` },
            signal,
          });
          let payload = {};
          try {
            payload = await response.json();
          } catch (error) {
            payload = {};
          }
          if (!response.ok) {
            const requestError = new Error(payload.detail || 'Unable to load sync data');
            requestError.status = response.status;
            throw requestError;
          }
          const result = payload.logs || [];
          
          // Cache the result
          setCachedData(cacheKey, STORAGE_KEYS.syncCache, result);
          
          return result;
        };

        const fetchTenders = async (authToken, query, signal) => {
          // Check cache first
          const cacheKey = createCacheKey('tenders', query);
          const cached = getCachedData(cacheKey, STORAGE_KEYS.tendersCache, 10); // Increased to 10 min
          if (cached) {
            return cached;
          }

          const response = await fetch(`${API_BASE}/insights/tenders${query}`, {
            headers: { Authorization: `Bearer ${authToken}` },
            signal,
          });
          let payload = {};
          try {
            payload = await response.json();
          } catch (error) {
            payload = {};
          }
          if (!response.ok) {
            const requestError = new Error(payload.detail || 'Unable to load tenders data');
            requestError.status = response.status;
            throw requestError;
          }
          
          // Cache the result
          setCachedData(cacheKey, STORAGE_KEYS.tendersCache, payload);
          
          return payload;
        };

        const fetchGateway = async (authToken, query, signal) => {
          // Check cache first
          const cacheKey = createCacheKey('gateway', query);
          const cached = getCachedData(cacheKey, STORAGE_KEYS.gatewayCache, 10); // Increased to 10 min
          if (cached) {
            return cached;
          }

          const response = await fetch(`${API_BASE}/insights/gateway${query}`, {
            headers: { Authorization: `Bearer ${authToken}` },
            signal,
          });
          let payload = {};
          try {
            payload = await response.json();
          } catch (error) {
            payload = {};
          }
          if (!response.ok) {
            const requestError = new Error(payload.detail || 'Unable to load gateway data');
            requestError.status = response.status;
            throw requestError;
          }
          
          // Cache the result
          setCachedData(cacheKey, STORAGE_KEYS.gatewayCache, payload);
          
          return payload;
        };

        const fetchOperations = async (authToken, query, signal) => {
          // Check cache first - operations data is cached per store and month
          const cacheKey = createCacheKey('operations', query);
          const cached = getCachedData(cacheKey, STORAGE_KEYS.operationsCache, 10); // Increased to 10 min
          if (cached) {
            return cached;
          }

          const response = await fetch(`${API_BASE}/insights/operations${query}`, {
            headers: { Authorization: `Bearer ${authToken}` },
            signal,
          });
          let payload = {};
          try {
            payload = await response.json();
          } catch (error) {
            payload = {};
          }
          if (!response.ok) {
            const requestError = new Error(payload.detail || 'Unable to load operations data');
            requestError.status = response.status;
            throw requestError;
          }
          
          // Cache the result
          setCachedData(cacheKey, STORAGE_KEYS.operationsCache, payload);
          
          return payload;
        };

        const fetchQuick = async (authToken, query, signal) => {
          // Check cache first
          const cacheKey = createCacheKey('quick', query);
          const cached = getCachedData(cacheKey, STORAGE_KEYS.quickCache, 10); // Increased to 10 min
          if (cached) {
            return cached;
          }

          const response = await fetch(`${API_BASE}/insights/quick${query}`, {
            headers: { Authorization: `Bearer ${authToken}` },
            signal,
          });
          let payload = {};
          try {
            payload = await response.json();
          } catch (error) {
            payload = {};
          }
          if (!response.ok) {
            const requestError = new Error(payload.detail || 'Unable to load quick insights');
            requestError.status = response.status;
            throw requestError;
          }
          
          // Cache the result
          setCachedData(cacheKey, STORAGE_KEYS.quickCache, payload);
          
          return payload;
        };

        const controllerRef = useRef(null);
        const debounceRef = useRef(null);
        const prevDateRangeRef = useRef(null);
        const prevPoRangeRef = useRef(null);
        const prevInvRangeRef = useRef(null);

        const loadInsights = async (authToken, query) => {
          if (!authToken) return;
          setIsLoadingData(true);
          if (controllerRef.current) {
            try { controllerRef.current.abort(); } catch {}
          }
          controllerRef.current = new AbortController();
          const { signal } = controllerRef.current;
          try {
            const [salesPayload, syncData, quickPayload] = await Promise.all([
              fetchSales(authToken, query, signal),
              fetchSyncLogs(authToken, query, signal),
              fetchQuick(authToken, query, signal).catch(() => null),
            ]);
            if (authToken !== tokenRef.current) {
              return;
            }
            setSales(salesPayload.sales || []);
            setSalesSummary(salesPayload.summary || null);
            setTopItems(salesPayload.topItems || []);
            setStoreMeta(salesPayload.store || null);
            setSalesBreakdowns({
              hourly: salesPayload.breakdowns?.hourly || [],
              payment: salesPayload.breakdowns?.payment_methods || [],
              payment_methods: salesPayload.breakdowns?.payment_methods || [],
              categories: salesPayload.breakdowns?.categories || [],
            });
            setPurchaseOrders(salesPayload.purchaseOrders || []);
            setInventorySnapshot(salesPayload.inventory || null);
            setSalesHistory(salesPayload.history || []);
            setSyncLogs(syncData);
            setQuickData(quickPayload);
            setAuthError('');
          } catch (error) {
            // Ignore expected aborts from canceled in-flight requests
            if (error && (error.name === 'AbortError' || (typeof error.message === 'string' && error.message.toLowerCase().includes('aborted')))) {
              return;
            }
            console.error(error);
            setSales([]);
            setSalesSummary(null);
            setTopItems([]);
            setStoreMeta(null);
            if (error.status === 401) {
              handleLogout('Session expired. Please sign in again.');
              return;
            }
            setAuthError(error.message || 'Unable to load dashboard data');
          } finally {
            setIsLoadingData(false);
          }
        };

        const loadModuleData = async (authToken, query, module) => {
          if (!authToken) return;
          setIsLoadingData(true);
          try {
            let payload = null;
            if (module === 'tenders') {
              // Load both tenders and gateway data for payment methods tab
              const [tendersPayload, gatewayPayload] = await Promise.all([
                fetchTenders(authToken, query),
                fetchGateway(authToken, query).catch(() => null),
              ]);
              setTendersData(tendersPayload);
              setGatewayData(gatewayPayload);
            } else if (module === 'operations') {
              // Operations tab shows overall data - only pass store parameter, no date filters
              // Extract store parameter from query string
              const queryParams = new URLSearchParams(storeQueryValue.replace('?', ''));
              const storeParam = queryParams.get('store');
              const opsQuery = storeParam ? `?store=${encodeURIComponent(storeParam)}` : '';
              payload = await fetchOperations(authToken, opsQuery);
              setOperationsData(payload);
            }
            setAuthError('');
          } catch (error) {
            console.error(error);
            if (error.status === 401) {
              handleLogout('Session expired. Please sign in again.');
              return;
            }
            setAuthError(error.message || 'Unable to load module data');
          } finally {
            setIsLoadingData(false);
          }
        };

        useEffect(() => {
          if (!token || userRole === 'admin') return;
          if (stores.length > 1 && !selectedStore) return;
          // Update ref with latest storeQueryValue
          storeQueryValueRef.current = storeQueryValue;
          // Always load insights when storeQueryValue changes (includes date changes and store changes)
          // This handles initial load, date range changes, and store changes
          loadInsights(token, storeQueryValue);
        }, [token, storeQueryValue, stores, selectedStore, userRole]);

        // Additional refresh trigger when date ranges change while on sales tab
        // This ensures data refreshes immediately when dates change (the first useEffect
        // should handle it via storeQueryValue, but this adds a safeguard)
        useEffect(() => {
          if (!token || userRole === 'admin') return;
          if (stores.length > 1 && !selectedStore) return;
          
          // Initialize refs on first run (skip refresh on initial mount)
          if (prevDateRangeRef.current === null) {
            prevDateRangeRef.current = dateRange;
            prevPoRangeRef.current = poRange;
            prevInvRangeRef.current = invRange;
            return;
          }
          
          // Compare date strings directly to catch all changes (including manual typing)
          const dateRangeChanged = 
            (prevDateRangeRef.current?.start || '') !== (dateRange?.start || '') ||
            (prevDateRangeRef.current?.end || '') !== (dateRange?.end || '');
          const poRangeChanged =
            (prevPoRangeRef.current?.start || '') !== (poRange?.start || '') ||
            (prevPoRangeRef.current?.end || '') !== (poRange?.end || '');
          const invRangeChanged =
            (prevInvRangeRef.current?.start || '') !== (invRange?.start || '') ||
            (prevInvRangeRef.current?.end || '') !== (invRange?.end || '');
          
          if (dateRangeChanged || poRangeChanged || invRangeChanged) {
            prevDateRangeRef.current = dateRange;
            prevPoRangeRef.current = poRange;
            prevInvRangeRef.current = invRange;
            
            // Only refresh if we have valid dates and are on the relevant tab
            const shouldRefresh = 
              (activeModule === 'sales' && dateRangeChanged && dateRange?.start) ||
              (activeModule === 'purchase' && poRangeChanged && (poRange?.start || poRange?.end)) ||
              (activeModule === 'inventory' && invRangeChanged && (invRange?.start || invRange?.end));
            
            if (shouldRefresh && token) {
              // Debounce the refresh to avoid too many requests
              if (debounceRef.current) clearTimeout(debounceRef.current);
              debounceRef.current = setTimeout(() => {
                if (token) {
                  // Use ref to get latest storeQueryValue (avoids stale closure)
                  loadInsights(token, storeQueryValueRef.current);
                }
              }, 300);
            }
          }
          
          return () => {
            if (debounceRef.current) clearTimeout(debounceRef.current);
          };
        }, [token, dateRange?.start, dateRange?.end, poRange?.start, poRange?.end, invRange?.start, invRange?.end, activeModule, stores, selectedStore, userRole, storeQueryValue]);

        useEffect(() => {
          if (!token || userRole === 'admin') return;
          if (stores.length > 1 && !selectedStore) return;
          if (['tenders', 'operations'].includes(activeModule)) {
            loadModuleData(token, storeQueryValue, activeModule);
          }
        }, [token, storeQueryValue, stores, selectedStore, userRole, activeModule]);

        const loadAdminUsers = useCallback(
          async (key) => {
            if (!key) {
              setAdminUsers([]);
              setSelectedAdminUserId(null);
              return [];
            }
            setIsAdminLoading(true);
            try {
              const response = await fetch(`${API_BASE}/admin/users`, {
                headers: { 'X-Admin-Key': key },
              });
              let data = {};
              try {
                data = await response.json();
              } catch (error) {
                data = {};
              }
              if (!response.ok) {
                const requestError = new Error(data.detail || 'Unable to load admin data');
                requestError.status = response.status;
                throw requestError;
              }
              const users = data.users || [];
              setAdminUsers(users);
              if (!users.length) {
                setSelectedAdminUserId(null);
              } else if (
                !selectedAdminUserId ||
                !users.some((user) => user.id === selectedAdminUserId)
              ) {
                setSelectedAdminUserId(users[0].id);
              }
              return users;
            } catch (error) {
              setAdminUsers([]);
              setSelectedAdminUserId(null);
              throw error;
            } finally {
              setIsAdminLoading(false);
            }
          },
          [selectedAdminUserId]
        );

        const handleAdminRefresh = useCallback(() => {
          if (!adminKey || userRole !== 'admin') return;
          setAdminError('');
          loadAdminUsers(adminKey).catch((error) => {
            if (error.status === 401) {
              handleAdminLogout('Admin key rejected. Please sign in again.');
            } else {
              setAdminError(error.message || 'Unable to refresh admin data');
            }
          });
        }, [adminKey, loadAdminUsers, handleAdminLogout, userRole]);

        useEffect(() => {
          if (!adminKey || userRole !== 'admin') return;
          setAdminError('');
          loadAdminUsers(adminKey).catch((error) => {
            if (error.status === 401) {
              handleAdminLogout('Admin key rejected. Please sign in again.');
            } else {
              setAdminError(error.message || 'Unable to load admin data');
            }
          });
        }, [adminKey, userRole, loadAdminUsers, handleAdminLogout]);

        const handleAdminCreateUser = useCallback(
          async (payload) => {
            if (!adminKey) {
              setAdminError('Admin session not active');
              return false;
            }
            setIsAdminProcessing(true);
            setAdminError('');
            setAdminMessage('');
            try {
              const response = await fetch(`${API_BASE}/admin/users`, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'X-Admin-Key': adminKey,
                },
                body: JSON.stringify(payload),
              });
              let data = {};
              try {
                data = await response.json();
              } catch (error) {
                data = {};
              }
              if (!response.ok) {
                const requestError = new Error(data.detail || 'Failed to create user');
                requestError.status = response.status;
                throw requestError;
              }
              const users = await loadAdminUsers(adminKey);
              const newUser = users.find((user) => user.id === data.id);
              if (newUser) {
                setSelectedAdminUserId(newUser.id);
              }
              setAdminMessage('User created successfully');
              return true;
            } catch (error) {
              if (error.status === 401) {
                handleAdminLogout('Admin session expired. Please sign in again.');
              } else {
                setAdminError(error.message || 'Failed to create user');
              }
              return false;
            } finally {
              setIsAdminProcessing(false);
            }
          },
          [adminKey, loadAdminUsers, handleAdminLogout]
        );

        const handleAdminEnsureStore = useCallback(
          async ({ store_db, db_user, db_pass }) => {
            if (!adminKey) {
              setAdminError('Admin session not active');
              return false;
            }
            setIsAdminProcessing(true);
            setAdminError('');
            setAdminMessage('');
            try {
              const response = await fetch(`${API_BASE}/admin/stores/provision`, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'X-Admin-Key': adminKey,
                },
                body: JSON.stringify({ store_db, db_user, db_pass }),
              });
              let data = {};
              try {
                data = await response.json();
              } catch (error) {
                data = {};
              }
              if (!response.ok) {
                const requestError = new Error(data.detail || 'Failed to provision database');
                requestError.status = response.status;
                throw requestError;
              }
              setAdminMessage('Database ensured successfully');
              return true;
            } catch (error) {
              if (error.status === 401) {
                handleAdminLogout('Admin session expired. Please sign in again.');
              } else {
                setAdminError(error.message || 'Failed to provision database');
              }
              return false;
            } finally {
              setIsAdminProcessing(false);
            }
          },
          [adminKey, handleAdminLogout]
        );

        const handleAdminAddStore = useCallback(
          async (userId, payload) => {
            if (!adminKey) {
              setAdminError('Admin session not active');
              return false;
            }
            setIsAdminProcessing(true);
            setAdminError('');
            setAdminMessage('');
            try {
              const response = await fetch(`${API_BASE}/admin/users/${userId}/stores`, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'X-Admin-Key': adminKey,
                },
                body: JSON.stringify(payload),
              });
              let data = {};
              try {
                data = await response.json();
              } catch (error) {
                data = {};
              }
              if (!response.ok) {
                const requestError = new Error(data.detail || 'Failed to add store');
                requestError.status = response.status;
                throw requestError;
              }
              await loadAdminUsers(adminKey);
              setSelectedAdminUserId(userId);
              setAdminMessage('Store added successfully');
              return true;
            } catch (error) {
              if (error.status === 401) {
                handleAdminLogout('Admin session expired. Please sign in again.');
              } else {
                setAdminError(error.message || 'Failed to add store');
              }
              return false;
            } finally {
              setIsAdminProcessing(false);
            }
          },
          [adminKey, loadAdminUsers, handleAdminLogout]
        );

        const handleAdminRemoveStore = useCallback(
          async (userId, identifier) => {
            if (!adminKey) {
              setAdminError('Admin session not active');
              return;
            }
            setIsAdminProcessing(true);
            setAdminError('');
            setAdminMessage('');
            try {
              const response = await fetch(
                `${API_BASE}/admin/users/${userId}/stores/${encodeURIComponent(identifier)}`,
                {
                  method: 'DELETE',
                  headers: {
                    'X-Admin-Key': adminKey,
                  },
                }
              );
              let data = {};
              try {
                data = await response.json();
              } catch (error) {
                data = {};
              }
              if (!response.ok) {
                const requestError = new Error(data.detail || 'Failed to remove store');
                requestError.status = response.status;
                throw requestError;
              }
              await loadAdminUsers(adminKey);
              setSelectedAdminUserId(userId);
              setAdminMessage('Store removed successfully');
            } catch (error) {
              if (error.status === 401) {
                handleAdminLogout('Admin session expired. Please sign in again.');
              } else {
                setAdminError(error.message || 'Failed to remove store');
              }
            } finally {
              setIsAdminProcessing(false);
            }
          },
          [adminKey, loadAdminUsers, handleAdminLogout]
        );

        const handleLogin = async ({ email, password }) => {
          setIsAuthenticating(true);
          setAuthError('');
          setAdminError('');
          setAdminMessage('');
          try {
            const response = await fetch(`${API_BASE}/auth/login`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ email, password }),
            });

            let data = {};
            try {
              data = await response.json();
            } catch (error) {
              data = {};
            }
            if (!response.ok) {
              throw new Error(data.detail || 'Login failed');
            }

            const nextRole = data.role || 'owner';
            const isAdminAccount = nextRole === 'admin';
            const nextStores = Array.isArray(data.stores) ? data.stores : [];
            const receivedKey = data.admin_key || '';

            setToken(data.token);
            setUserRole(nextRole);
            setProfile((prev) => ({
              email: data.email || prev?.email || email,
              full_name: data.full_name || prev?.full_name || '',
            }));

            if (isAdminAccount) {
              setStores([]);
              setSelectedStore(null);
              setSales([]);
              setSalesSummary(null);
              setTopItems([]);
              setStoreMeta(null);
            setSalesBreakdowns({ hourly: [], payment: [], payment_methods: [], categories: [] });
              setPurchaseOrders([]);
              setInventorySnapshot(null);
              setSalesHistory([]);
              setSyncLogs([]);
              setTendersData(null);
              setGatewayData(null);
              setOperationsData(null);
              setQuickData(null);
              setAdminUsers([]);
              setSelectedAdminUserId(null);
              setAdminMessage('');
              setAdminKey(receivedKey);
              if (!receivedKey) {
                setAdminError('Admin tools are unavailable because ADMIN_API_KEY is not configured on the server.');
              } else {
                setAdminError('');
              }
              setActiveModule('sales');
            } else {
              setStores(nextStores);
              setSelectedStore(nextStores[0] || null);
              setAdminKey('');
              setAdminUsers([]);
              setSelectedAdminUserId(null);
              setSales([]);
              setSalesSummary(null);
              setTopItems([]);
              setStoreMeta(null);
              setSalesBreakdowns({ hourly: [], payment: [], payment_methods: [], categories: [] });
              setPurchaseOrders([]);
              setInventorySnapshot(null);
              setSalesHistory([]);
              setSyncLogs([]);
              setTendersData(null);
              setGatewayData(null);
              setOperationsData(null);
              setQuickData(null);
              setActiveModule('sales');
            }

            setIsLoadingData(false);
            setAuthError('');
          } catch (error) {
            setAuthError(error.message);
          } finally {
            setIsAuthenticating(false);
          }
        };

        const refresh = () => {
          if (debounceRef.current) clearTimeout(debounceRef.current);
          debounceRef.current = setTimeout(() => {
            if (token && userRole !== 'admin') {
              loadInsights(token, storeQueryValue);
            }
          }, 400);
        };

        const handleStoreChange = useCallback((nextStore) => {
          // Clear all caches when store changes to ensure fresh data
          clearAllCaches();
          
          // Reset all data states to show loading state immediately
          setSales([]);
          setSalesSummary(null);
          setTopItems([]);
          setStoreMeta(null);
          setSalesBreakdowns({ hourly: [], payment: [], payment_methods: [], categories: [] });
          setPurchaseOrders([]);
          setInventorySnapshot(null);
          setSalesHistory([]);
          setTendersData(null);
          setGatewayData(null);
          setOperationsData(null);
          setQuickData(null);
          setIsLoadingData(true);
          
          // Update store - this will trigger storeQueryValue to update, which triggers useEffect to load data
          setSelectedStore(nextStore || null);
        }, []);

        const [loginView, setLoginView] = useState('selection'); // 'selection', 'insights', 'mobility'
        const [isConnectingMobility, setIsConnectingMobility] = useState(false);
        const [mobilityError, setMobilityError] = useState('');

        const handleMobilityConnect = (ip, port) => {
          setIsConnectingMobility(true);
          setMobilityError('');
          
          // Construct the URL for Spirits Mobility
          // Spirits Mobility is a PHP program where index.html controls the login process
          // Always use unsecured HTTP (not HTTPS)
          const mobilityUrl = `http://${ip}:${port}/index.html`;
          
          // Try to connect to the Mobility server (optional check)
          // This helps verify the server is reachable before redirecting
          fetch(`${mobilityUrl}`, { 
            method: 'HEAD',
            mode: 'no-cors',
            cache: 'no-cache'
          }).catch(() => {
            // Ignore CORS errors - the server might not allow CORS, but we'll still try to navigate
          });
          
          // Redirect to the Spirits Mobility login screen (index.html) using unsecured HTTP
          setTimeout(() => {
            window.location.href = mobilityUrl;
          }, 500);
        };

        if (!token) {
          return (
            <div className="login-layout">
              <div className="login-card">
                <h1>Spirits Store Insights</h1>
                <p>Choose your login option to continue.</p>
                {loginView === 'selection' && (
                  <LoginSelection
                    onSelectInsights={() => setLoginView('insights')}
                    onSelectMobility={() => setLoginView('mobility')}
                  />
                )}
                {loginView === 'insights' && (
                  <>
                    <LoginForm onSubmit={handleLogin} isLoading={isAuthenticating} error={authError} />
                    <button
                      type="button"
                      className="secondary"
                      onClick={() => setLoginView('selection')}
                      style={{ marginTop: '0.5rem', width: '100%' }}
                    >
                      Back
                    </button>
                  </>
                )}
                {loginView === 'mobility' && (
                  <MobilityConnectionForm
                    onConnect={handleMobilityConnect}
                    onBack={() => setLoginView('selection')}
                    isLoading={isConnectingMobility}
                    error={mobilityError}
                  />
                )}
              </div>
            </div>
          );
        }

        const mainContent = userRole === 'admin'
          ? (
              <div className="admin-layout">
                <AdminView
                  hasKey={Boolean(adminKey)}
                  users={adminUsers}
                  selectedUserId={selectedAdminUserId}
                  onSelectUser={setSelectedAdminUserId}
                  onRefresh={handleAdminRefresh}
                  onCreateUser={handleAdminCreateUser}
                  onAddStore={handleAdminAddStore}
                  onRemoveStore={handleAdminRemoveStore}
                  onEnsureStore={handleAdminEnsureStore}
                  isLoading={isAdminLoading}
                  isProcessing={isAdminProcessing}
                  error={adminError}
                  message={adminMessage}
                />
              </div>
            )
          : (
              <Dashboard
                stores={stores}
                selectedStore={selectedStore}
                storeInfo={storeMeta}
                sales={sales}
                summary={salesSummary}
                topItems={topItems}
                breakdowns={salesBreakdowns}
                syncLogs={syncLogs}
                purchaseOrders={purchaseOrders}
                inventory={inventorySnapshot}
                history={salesHistory}
                tendersData={tendersData}
                gatewayData={gatewayData}
                operationsData={operationsData}
                quickData={quickData}
                onStoreChange={handleStoreChange}
                onRefresh={refresh}
                activeModule={activeModule}
                onModuleChange={setActiveModule}
                loading={isLoadingData}
                error={authError}
                dateRange={dateRange}
                onDateRangeChange={handleDateRangeChange}
                poRange={poRange}
                token={token}
                storeQueryValue={storeQueryValue}
                onPoRangeChange={handlePoRangeChange}
                invRange={invRange}
                onInvRangeChange={handleInvRangeChange}
              />
            );

        return (
          <div className="app-shell">
            <HeaderBar
              profile={profile}
              stores={userRole === 'admin' ? [] : stores}
              selectedStore={userRole === 'admin' ? null : selectedStore}
              onStoreChange={handleStoreChange}
              onLogout={() => handleLogout('')}
            />
            {mainContent}
          </div>
        );
      };

      ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
  </body>
</html>
