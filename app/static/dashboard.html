<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Store Insights Dashboard</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        color-scheme: light dark;
        font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        --surface: #ffffff;
        --surface-alt: #f6f8fb;
        --border: #d0d7e2;
        --primary: #2563eb;
        --primary-dark: #1e3a8a;
        --text: #111827;
        --muted: #6b7280;
        --danger: #dc2626;
      }

      body {
        margin: 0;
        background: var(--surface-alt);
        color: var(--text);
      }

      .app-shell {
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }

      header {
        padding: 1.5rem clamp(1.5rem, 4vw, 3rem);
        background: var(--surface);
        border-bottom: 1px solid var(--border);
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 1rem;
      }

      header h1 {
        margin: 0;
        font-size: clamp(1.25rem, 2.5vw, 1.75rem);
      }

      header span {
        color: var(--muted);
        font-size: 0.95rem;
      }

      main {
        flex: 1;
        padding: clamp(1.5rem, 4vw, 3rem);
        display: grid;
        gap: clamp(1.5rem, 3vw, 2.5rem);
        grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
        align-content: start;
      }

      .card {
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 1rem;
        padding: clamp(1.5rem, 3vw, 2rem);
        box-shadow: 0 8px 24px rgba(15, 23, 42, 0.04);
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .card h2 {
        margin: 0;
        font-size: 1.1rem;
      }

      .card.error-card {
        border-color: #fecaca;
        background: #fef2f2;
        color: #7f1d1d;
      }

      form,
      .controls {
        display: grid;
        gap: 1rem;
      }

      .controls {
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        align-items: end;
      }

      .control-actions {
        display: flex;
        gap: 0.75rem;
        flex-wrap: wrap;
        justify-content: flex-start;
        align-items: center;
      }

      @media (min-width: 768px) {
        .control-actions {
          justify-content: flex-end;
        }
      }

      label {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        font-weight: 500;
      }

      input,
      select,
      button {
        font: inherit;
        border-radius: 0.75rem;
        border: 1px solid var(--border);
        padding: 0.75rem 1rem;
        background: #fff;
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
      }

      input,
      select {
        color: var(--text);
      }

      input::placeholder {
        color: var(--muted);
      }

      input:focus,
      select:focus,
      button:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 4px rgba(37, 99, 235, 0.12);
      }

      button {
        background: var(--primary);
        color: #fff;
        font-weight: 600;
        cursor: pointer;
        border: none;
      }

      .secondary-button {
        background: transparent;
        color: var(--muted);
        border: 1px solid var(--border);
      }

      .secondary-button:hover {
        color: var(--primary-dark);
        border-color: var(--primary);
        background: rgba(37, 99, 235, 0.08);
      }

      button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .error-message {
        color: var(--danger);
        font-size: 0.95rem;
      }

      table {
        width: 100%;
        border-collapse: collapse;
      }

      thead {
        background: var(--surface-alt);
      }

      th,
      td {
        padding: 0.75rem;
        border-bottom: 1px solid var(--border);
        text-align: left;
        font-size: 0.95rem;
      }

      tr:last-child td {
        border-bottom: none;
      }

      .status-pill {
        display: inline-flex;
        align-items: center;
        padding: 0.25rem 0.75rem;
        border-radius: 999px;
        font-size: 0.85rem;
        font-weight: 600;
        background: #e5edff;
        color: var(--primary-dark);
        text-transform: capitalize;
      }

      .status-pill[data-status="failed"] {
        background: #fee2e2;
        color: #991b1b;
      }

      .status-pill[data-status="success"] {
        background: #dcfce7;
        color: #166534;
      }

      .empty-state {
        color: var(--muted);
        text-align: center;
        padding: 2rem 1rem;
      }

      .metrics {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 1rem;
      }

      .metrics div {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }

      .metric-label {
        color: var(--muted);
        font-size: 0.85rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
      }

      .metric-value {
        font-size: 1.4rem;
        font-weight: 600;
      }

      canvas {
        max-width: 100%;
      }

      @media (max-width: 768px) {
        header {
          flex-direction: column;
          align-items: flex-start;
        }

        main {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="app-shell">
      <header>
        <h1>Store Insights</h1>
        <span id="store-meta"></span>
      </header>
      <main id="root"></main>
    </div>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

    <script type="text/babel">
      const { useState, useMemo, useEffect, useRef, useCallback } = React;
      const API_BASE = '';

      const STORAGE_KEYS = {
        token: 'store-insights/token',
        stores: 'store-insights/stores',
        selectedStore: 'store-insights/selected-store',
      };

      const getStorage = () => {
        try {
          if (typeof window === 'undefined' || !window.localStorage) {
            return null;
          }
          return window.localStorage;
        } catch (error) {
          console.warn('Storage unavailable', error);
          return null;
        }
      };

      const storageBackend = getStorage();

      const storage = {
        get(key, fallback = null) {
          if (!storageBackend) return fallback;
          const rawValue = storageBackend.getItem(key);
          if (rawValue === null) return fallback;
          try {
            return JSON.parse(rawValue);
          } catch (error) {
            return rawValue;
          }
        },
        set(key, value) {
          if (!storageBackend) return;
          if (value === undefined || value === null) {
            storageBackend.removeItem(key);
            return;
          }
          const serialized =
            typeof value === 'string' ? value : JSON.stringify(value);
          storageBackend.setItem(key, serialized);
        },
        remove(key) {
          if (!storageBackend) return;
          storageBackend.removeItem(key);
        },
        clearSession() {
          if (!storageBackend) return;
          Object.values(STORAGE_KEYS).forEach((key) => storageBackend.removeItem(key));
        },
      };

      const getStoreIdentifier = (store) => {
        if (!store) return '';
        return store.store_id ?? store.store_db ?? '';
      };

      const StoreSelector = ({ stores, selectedStore, onChange }) => {
        if (!stores?.length) return null;
        const options = stores.map((store) => ({
          value: getStoreIdentifier(store) || store.store_db || String(store.store_name || ''),
          label: store.store_name || store.store_db || `Store #${store.store_id}`,
        }));

        const selectedValue = getStoreIdentifier(selectedStore) || options[0]?.value || '';

        useEffect(() => {
          if (!selectedStore && options.length) {
            const first = stores.find((s) => getStoreIdentifier(s) === options[0].value) || stores[0];
            onChange(first);
          }
        }, [stores, selectedStore, onChange]);

        if (stores.length === 1) {
          return (
            <div>
              <span className="metric-label">Store</span>
              <div>{options[0]?.label}</div>
            </div>
          );
        }

        return (
          <label>
            Store
            <select
              value={selectedValue}
              onChange={(event) => {
                const selected = stores.find((store) => getStoreIdentifier(store) === event.target.value);
                onChange(selected);
              }}
            >
              {options.map((option) => (
                <option key={option.value} value={option.value}>
                  {option.label}
                </option>
              ))}
            </select>
          </label>
        );
      };

      const SalesChart = ({ sales }) => {
        const canvasRef = useRef(null);
        const chartRef = useRef(null);

        useEffect(() => {
          const canvas = canvasRef.current;
          if (!canvas) return;

          if (!sales?.length) {
            if (chartRef.current) {
              chartRef.current.destroy();
              chartRef.current = null;
            }
            return;
          }

          const labels = sales.map((item) => item.date).reverse();
          const totals = sales.map((item) => item.total_sales).reverse();
          const qty = sales.map((item) => item.total_items_sold).reverse();

          if (chartRef.current) {
            chartRef.current.data.labels = labels;
            chartRef.current.data.datasets[0].data = totals;
            chartRef.current.data.datasets[1].data = qty;
            chartRef.current.update();
            return;
          }

          chartRef.current = new Chart(canvas, {
            type: 'line',
            data: {
              labels,
              datasets: [
                {
                  label: 'Sales ($)',
                  data: totals,
                  borderColor: '#2563eb',
                  backgroundColor: 'rgba(37, 99, 235, 0.12)',
                  tension: 0.35,
                  fill: true,
                  yAxisID: 'y',
                },
                {
                  label: 'Items Sold',
                  data: qty,
                  borderColor: '#f97316',
                  backgroundColor: 'rgba(249, 115, 22, 0.12)',
                  tension: 0.35,
                  fill: true,
                  yAxisID: 'y1',
                },
              ],
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                y: {
                  position: 'left',
                  title: { display: true, text: 'Sales ($)' },
                },
                y1: {
                  position: 'right',
                  grid: { drawOnChartArea: false },
                  title: { display: true, text: 'Items' },
                },
              },
              plugins: {
                legend: { display: true },
                tooltip: { mode: 'index', intersect: false },
              },
            },
          });

          return () => {
            if (chartRef.current) {
              chartRef.current.destroy();
              chartRef.current = null;
            }
          };
        }, [sales]);

        if (!sales?.length) {
          return <div className="empty-state">No sales data available for charting.</div>;
        }

        return <canvas ref={canvasRef} height="220"></canvas>;
      };

      const SyncTable = ({ logs }) => {
        if (!logs?.length) {
          return <div className="empty-state">No sync activity logged yet.</div>;
        }

        const formatNumber = (value) => {
          if (value === null || value === undefined) return '—';
          const parsed = Number(value);
          return Number.isNaN(parsed) ? value : parsed.toLocaleString();
        };

        return (
          <div className="table-wrapper">
            <table>
              <thead>
                <tr>
                  <th>Store</th>
                  <th>Status</th>
                  <th>Started</th>
                  <th>Finished</th>
                  <th>Records</th>
                  <th>Message</th>
                </tr>
              </thead>
              <tbody>
                {logs.map((log) => (
                  <tr key={`${log.id}-${log.started_at}`}> 
                    <td>{log.store_name || log.store_db || '—'}</td>
                    <td>
                      <span className="status-pill" data-status={(log.status || '').toLowerCase()}>
                        {log.status || '—'}
                      </span>
                    </td>
                    <td>{log.started_at ? new Date(log.started_at).toLocaleString() : '—'}</td>
                    <td>{log.finished_at ? new Date(log.finished_at).toLocaleString() : '—'}</td>
                    <td>{formatNumber(log.records_processed)}</td>
                    <td>{log.message || '—'}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        );
      };

      const LoginForm = ({ onSubmit, isLoading, error }) => {
        const [email, setEmail] = useState('');
        const [password, setPassword] = useState('');

        const submit = (event) => {
          event.preventDefault();
          onSubmit({ email, password });
        };

        return (
          <form onSubmit={submit}>
            <label htmlFor="email">
              Email
              <input
                id="email"
                type="email"
                placeholder="you@example.com"
                value={email}
                onChange={(event) => setEmail(event.target.value)}
                required
              />
            </label>
            <label htmlFor="password">
              Password
              <input
                id="password"
                type="password"
                placeholder="••••••••"
                value={password}
                onChange={(event) => setPassword(event.target.value)}
                required
              />
            </label>
            {error ? <div className="error-message">{error}</div> : null}
            <button type="submit" disabled={isLoading}>
              {isLoading ? 'Signing in…' : 'Sign in'}
            </button>
          </form>
        );
      };

      const Dashboard = ({
        token,
        stores,
        selectedStore,
        sales,
        syncLogs,
        onStoreChange,
        onRefresh,
        onLogout,
        loading,
        error,
      }) => {
        useEffect(() => {
          const storeMeta = document.getElementById('store-meta');
          if (!storeMeta) return;
          if (!token) {
            storeMeta.textContent = '';
            return;
          }

          const name = selectedStore?.store_name || selectedStore?.store_db;
          storeMeta.textContent = name ? `Viewing ${name}` : 'Select a store to begin';
        }, [token, selectedStore]);

        const summary = useMemo(() => {
          return sales.reduce(
            (acc, day) => {
              acc.sales += Number(day.total_sales || 0);
              acc.items += Number(day.total_items_sold || 0);
              return acc;
            },
            { sales: 0, items: 0 }
          );
        }, [sales]);

        return (
          <>
            {error ? (
              <section className="card error-card">
                <h2>Heads up</h2>
                <p>{error}</p>
              </section>
            ) : null}

            <section className="card">
              <h2>Store Controls</h2>
              <div className="controls">
                <StoreSelector stores={stores} selectedStore={selectedStore} onChange={onStoreChange} />
                <div className="control-actions">
                  <button type="button" onClick={onRefresh} disabled={loading}>
                    {loading ? 'Refreshing…' : 'Refresh insights'}
                  </button>
                  <button type="button" className="secondary-button" onClick={onLogout}>
                    Sign out
                  </button>
                </div>
              </div>
            </section>

            <section className="card">
              <h2>7-Day Summary</h2>
              {sales.length ? (
                <div className="metrics">
                  <div>
                    <span className="metric-label">Gross sales</span>
                    <span className="metric-value">
                      ${summary.sales.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}
                    </span>
                  </div>
                  <div>
                    <span className="metric-label">Items sold</span>
                    <span className="metric-value">{summary.items.toLocaleString()}</span>
                  </div>
                  <div>
                    <span className="metric-label">Days captured</span>
                    <span className="metric-value">{sales.length}</span>
                  </div>
                </div>
              ) : (
                <div className="empty-state">No sales recorded in the last 7 days.</div>
              )}
            </section>

            <section className="card">
              <h2>Daily Sales</h2>
              {sales.length ? (
                <table>
                  <thead>
                    <tr>
                      <th>Date</th>
                      <th>Items Sold</th>
                      <th>Total Sales ($)</th>
                    </tr>
                  </thead>
                  <tbody>
                    {sales.map((sale) => (
                      <tr key={sale.date}>
                        <td>{sale.date}</td>
                        <td>{sale.total_items_sold}</td>
                        <td>{sale.total_sales.toLocaleString(undefined, { minimumFractionDigits: 2 })}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              ) : (
                <div className="empty-state">No sales recorded in the last 7 days.</div>
              )}
            </section>

            <section className="card">
              <h2>Sales Trend (7 Days)</h2>
              <SalesChart sales={sales} />
            </section>

            <section className="card">
              <h2>DBF Sync Activity</h2>
              <SyncTable logs={syncLogs} />
            </section>
          </>
        );
      };

      const App = () => {
        const [token, setToken] = useState(() => storage.get(STORAGE_KEYS.token, null));
        const [stores, setStores] = useState(() => storage.get(STORAGE_KEYS.stores, []));
        const [selectedStore, setSelectedStore] = useState(() =>
          storage.get(STORAGE_KEYS.selectedStore, null)
        );
        const [sales, setSales] = useState([]);
        const [syncLogs, setSyncLogs] = useState([]);
        const [authError, setAuthError] = useState('');
        const [isAuthenticating, setIsAuthenticating] = useState(false);
        const [isLoadingData, setIsLoadingData] = useState(false);

        const tokenRef = useRef(token);

        const storeQueryValue = useMemo(() => {
          const identifier = getStoreIdentifier(selectedStore);
          return identifier ? `?store=${encodeURIComponent(identifier)}` : '';
        }, [selectedStore]);

        const handleLogout = useCallback((message = '') => {
          storage.clearSession();
          setToken(null);
          setStores([]);
          setSelectedStore(null);
          setSales([]);
          setSyncLogs([]);
          tokenRef.current = null;
          setAuthError(message);
          setIsAuthenticating(false);
          setIsLoadingData(false);
        }, []);

        useEffect(() => {
          tokenRef.current = token;
          if (token) {
            storage.set(STORAGE_KEYS.token, token);
          } else {
            storage.remove(STORAGE_KEYS.token);
          }
        }, [token]);

        useEffect(() => {
          if (stores?.length) {
            storage.set(STORAGE_KEYS.stores, stores);
          } else {
            storage.remove(STORAGE_KEYS.stores);
          }
        }, [stores]);

        useEffect(() => {
          if (selectedStore) {
            storage.set(STORAGE_KEYS.selectedStore, selectedStore);
          } else {
            storage.remove(STORAGE_KEYS.selectedStore);
          }
        }, [selectedStore]);

        useEffect(() => {
          if (!stores?.length) {
            if (selectedStore) {
              setSelectedStore(null);
            }
            return;
          }

          if (!selectedStore) {
            setSelectedStore(stores[0]);
            return;
          }

          const identifier = getStoreIdentifier(selectedStore);
          const match = stores.find((store) => getStoreIdentifier(store) === identifier);
          if (!match) {
            setSelectedStore(stores[0]);
          } else if (match !== selectedStore) {
            setSelectedStore(match);
          }
        }, [stores, selectedStore]);

        const fetchSales = async (authToken, query) => {
          const response = await fetch(`${API_BASE}/insights/sales${query}`, {
            headers: { Authorization: `Bearer ${authToken}` },
          });
          let payload = {};
          try {
            payload = await response.json();
          } catch (error) {
            payload = {};
          }
          if (!response.ok) {
            const requestError = new Error(payload.detail || 'Unable to load sales data');
            requestError.status = response.status;
            throw requestError;
          }
          return payload.sales || [];
        };

        const fetchSyncLogs = async (authToken, query) => {
          const response = await fetch(`${API_BASE}/sync/status${query}`, {
            headers: { Authorization: `Bearer ${authToken}` },
          });
          let payload = {};
          try {
            payload = await response.json();
          } catch (error) {
            payload = {};
          }
          if (!response.ok) {
            const requestError = new Error(payload.detail || 'Unable to load sync data');
            requestError.status = response.status;
            throw requestError;
          }
          return payload.logs || [];
        };

        const loadInsights = async (authToken, query) => {
          if (!authToken) return;
          setIsLoadingData(true);
          try {
            const [salesData, syncData] = await Promise.all([
              fetchSales(authToken, query),
              fetchSyncLogs(authToken, query),
            ]);
            if (authToken !== tokenRef.current) {
              return;
            }
            setSales(salesData);
            setSyncLogs(syncData);
            setAuthError('');
          } catch (error) {
            console.error(error);
            if (error.status === 401) {
              handleLogout('Session expired. Please sign in again.');
              return;
            }
            setAuthError(error.message || 'Unable to load dashboard data');
          } finally {
            setIsLoadingData(false);
          }
        };

        useEffect(() => {
          if (!token) return;
          if (stores.length > 1 && !selectedStore) return;
          loadInsights(token, storeQueryValue);
        }, [token, storeQueryValue, stores, selectedStore]);

        const handleLogin = async ({ email, password }) => {
          setIsAuthenticating(true);
          setAuthError('');
          try {
            const response = await fetch(`${API_BASE}/auth/login`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ email, password }),
            });

            let data = {};
            try {
              data = await response.json();
            } catch (error) {
              data = {};
            }
            if (!response.ok) {
              throw new Error(data.detail || 'Login failed');
            }

            setToken(data.token);
            setStores(data.stores || []);
            if (data.stores?.length) {
              setSelectedStore(data.stores[0]);
            } else {
              setSelectedStore(null);
            }
          } catch (error) {
            setAuthError(error.message);
          } finally {
            setIsAuthenticating(false);
          }
        };

        const refresh = () => {
          if (token) {
            loadInsights(token, storeQueryValue);
          }
        };

        if (!token) {
          return (
            <section className="card">
              <h2>Sign in</h2>
              <LoginForm onSubmit={handleLogin} isLoading={isAuthenticating} error={authError} />
            </section>
          );
        }

        return (
          <Dashboard
            token={token}
            stores={stores}
            selectedStore={selectedStore}
            sales={sales}
            syncLogs={syncLogs}
            onStoreChange={setSelectedStore}
            onRefresh={refresh}
            onLogout={handleLogout}
            loading={isLoadingData}
            error={authError}
          />
        );
      };

      ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
  </body>
</html>
