<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Store Insights Dashboard</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        color-scheme: light dark;
        font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        --surface: #ffffff;
        --surface-alt: #f6f8fb;
        --border: #d0d7e2;
        --primary: #2563eb;
        --primary-dark: #1e3a8a;
        --text: #111827;
        --muted: #6b7280;
        --danger: #dc2626;
      }

      body {
        margin: 0;
        background: var(--surface-alt);
        color: var(--text);
      }

      .app-shell {
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }

      header {
        padding: 1.5rem clamp(1.5rem, 4vw, 3rem);
        background: var(--surface);
        border-bottom: 1px solid var(--border);
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 1rem;
      }

      header h1 {
        margin: 0;
        font-size: clamp(1.25rem, 2.5vw, 1.75rem);
      }

      header span {
        color: var(--muted);
        font-size: 0.95rem;
      }

      main {
        flex: 1;
        padding: clamp(1.5rem, 4vw, 3rem);
        display: grid;
        gap: clamp(1.5rem, 3vw, 2.5rem);
        grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
        align-content: start;
      }

      .card {
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 1rem;
        padding: clamp(1.5rem, 3vw, 2rem);
        box-shadow: 0 8px 24px rgba(15, 23, 42, 0.04);
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .card h2 {
        margin: 0;
        font-size: 1.1rem;
      }

      .card.error-card {
        border-color: #fecaca;
        background: #fef2f2;
        color: #7f1d1d;
      }

      form,
      .controls {
        display: grid;
        gap: 1rem;
      }

      .controls {
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        align-items: end;
      }

      .control-actions {
        display: flex;
        gap: 0.75rem;
        flex-wrap: wrap;
        justify-content: flex-start;
        align-items: center;
      }

      @media (min-width: 768px) {
        .control-actions {
          justify-content: flex-end;
        }
      }

      label {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        font-weight: 500;
      }

      input,
      select,
      button {
        font: inherit;
        border-radius: 0.75rem;
        border: 1px solid var(--border);
        padding: 0.75rem 1rem;
        background: #fff;
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
      }

      input,
      select {
        color: var(--text);
      }

      input::placeholder {
        color: var(--muted);
      }

      input:focus,
      select:focus,
      button:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 4px rgba(37, 99, 235, 0.12);
      }

      button {
        background: var(--primary);
        color: #fff;
        font-weight: 600;
        cursor: pointer;
        border: none;
      }

      .secondary-button {
        background: transparent;
        color: var(--muted);
        border: 1px solid var(--border);
      }

      .secondary-button:hover {
        color: var(--primary-dark);
        border-color: var(--primary);
        background: rgba(37, 99, 235, 0.08);
      }

      button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }

      .error-message {
        color: var(--danger);
        font-size: 0.95rem;
      }

      table {
        width: 100%;
        border-collapse: collapse;
      }

      thead {
        background: var(--surface-alt);
      }

      th,
      td {
        padding: 0.75rem;
        border-bottom: 1px solid var(--border);
        text-align: left;
        font-size: 0.95rem;
      }

      tr:last-child td {
        border-bottom: none;
      }

      .status-pill {
        display: inline-flex;
        align-items: center;
        padding: 0.25rem 0.75rem;
        border-radius: 999px;
        font-size: 0.85rem;
        font-weight: 600;
        background: #e5edff;
        color: var(--primary-dark);
        text-transform: capitalize;
      }

      .status-pill[data-status="failed"] {
        background: #fee2e2;
        color: #991b1b;
      }

      .status-pill[data-status="success"] {
        background: #dcfce7;
        color: #166534;
      }

      .empty-state {
        color: var(--muted);
        text-align: center;
        padding: 2rem 1rem;
      }

      .metrics {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 1rem;
      }

      .metrics div {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }

      .tab-group {
        display: inline-flex;
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 999px;
        padding: 0.25rem;
        gap: 0.25rem;
      }

      .tab-container {
        display: flex;
        justify-content: center;
        width: 100%;
        margin-bottom: clamp(1rem, 3vw, 1.5rem);
      }

      .tab-button {
        border: none;
        background: transparent;
        color: var(--muted);
        font-weight: 500;
        padding: 0.35rem 1rem;
        border-radius: 999px;
        cursor: pointer;
        transition: background-color 0.2s ease, color 0.2s ease;
      }

      .tab-button[data-active="true"] {
        background: var(--primary);
        color: #fff;
        box-shadow: 0 6px 14px rgba(37, 99, 235, 0.18);
      }

      .success-message {
        color: #166534;
        background: #dcfce7;
        border: 1px solid #bbf7d0;
        padding: 0.75rem 1rem;
        border-radius: 0.75rem;
      }

      .admin-toolbar {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 1rem;
        flex-wrap: wrap;
      }

      .admin-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
        gap: clamp(1.5rem, 3vw, 2.5rem);
      }

      .user-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: grid;
        gap: 0.75rem;
      }

      .user-list button {
        width: 100%;
        text-align: left;
        border: 1px solid var(--border);
        background: var(--surface-alt);
        border-radius: 0.75rem;
        padding: 0.75rem 1rem;
        display: grid;
        gap: 0.35rem;
        transition: border-color 0.2s ease, transform 0.2s ease;
        cursor: pointer;
      }

      .user-list button:hover {
        border-color: var(--primary);
        transform: translateY(-1px);
      }

      .user-list button[data-active="true"] {
        border-color: var(--primary);
        background: rgba(37, 99, 235, 0.08);
      }

      .user-email {
        font-weight: 600;
      }

      .user-meta {
        color: var(--muted);
        font-size: 0.85rem;
      }

      .admin-form {
        display: grid;
        gap: 1rem;
        margin-top: 1.5rem;
      }

      .store-list {
        display: grid;
        gap: 0.75rem;
      }

      .store-card {
        border: 1px solid var(--border);
        border-radius: 0.75rem;
        padding: 0.75rem 1rem;
        background: var(--surface-alt);
        display: grid;
        gap: 0.5rem;
      }

      .store-card-heading {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.5rem;
      }

      .store-card-heading h4 {
        margin: 0;
        font-size: 1rem;
      }

      .store-card-details {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 0.5rem 1rem;
        margin: 0;
      }

      .store-card-detail {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
      }

      .store-card-details dt {
        font-size: 0.8rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--muted);
      }

      .store-card-details dd {
        margin: 0;
        font-weight: 500;
        font-size: 0.95rem;
        word-break: break-word;
      }

      .metric-label {
        color: var(--muted);
        font-size: 0.85rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
      }

      .metric-value {
        font-size: 1.4rem;
        font-weight: 600;
      }

      canvas {
        max-width: 100%;
      }

      @media (max-width: 768px) {
        header {
          flex-direction: column;
          align-items: flex-start;
        }

        main {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="app-shell">
      <header>
        <h1>Store Insights</h1>
        <span id="store-meta"></span>
      </header>
      <main id="root"></main>
    </div>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>

    <script type="text/babel">
      const { useState, useMemo, useEffect, useRef, useCallback } = React;
      const API_BASE = '';

      const STORAGE_KEYS = {
        token: 'store-insights/token',
        stores: 'store-insights/stores',
        selectedStore: 'store-insights/selected-store',
        adminKey: 'store-insights/admin-key',
        role: 'store-insights/role',
      };

      const getStorage = () => {
        try {
          if (typeof window === 'undefined' || !window.localStorage) {
            return null;
          }
          return window.localStorage;
        } catch (error) {
          console.warn('Storage unavailable', error);
          return null;
        }
      };

      const storageBackend = getStorage();

      const storage = {
        get(key, fallback = null) {
          if (!storageBackend) return fallback;
          const rawValue = storageBackend.getItem(key);
          if (rawValue === null) return fallback;
          try {
            return JSON.parse(rawValue);
          } catch (error) {
            return rawValue;
          }
        },
        set(key, value) {
          if (!storageBackend) return;
          if (value === undefined || value === null) {
            storageBackend.removeItem(key);
            return;
          }
          const serialized =
            typeof value === 'string' ? value : JSON.stringify(value);
          storageBackend.setItem(key, serialized);
        },
        remove(key) {
          if (!storageBackend) return;
          storageBackend.removeItem(key);
        },
        clearSession() {
          if (!storageBackend) return;
          Object.entries(STORAGE_KEYS).forEach(([name, key]) => {
            if (name === 'adminKey') return;
            storageBackend.removeItem(key);
          });
        },
      };

      const getStoreIdentifier = (store) => {
        if (!store) return '';
        return store.store_id ?? store.store_db ?? '';
      };

      const formatRole = (role) => {
        if (!role) return '—';
        return role.charAt(0).toUpperCase() + role.slice(1);
      };

      const decodeRoleFromToken = (token) => {
        if (!token || typeof window === 'undefined' || typeof window.atob !== 'function') {
          return '';
        }

        try {
          const segments = token.split('.');
          if (segments.length < 2) {
            return '';
          }

          const payload = segments[1].replace(/-/g, '+').replace(/_/g, '/');
          const padded = payload.padEnd(Math.ceil(payload.length / 4) * 4, '=');
          const decoded = JSON.parse(window.atob(padded));
          return decoded?.role || '';
        } catch (error) {
          console.warn('Unable to decode token role', error);
          return '';
        }
      };

      const StoreSelector = ({ stores, selectedStore, onChange }) => {
        if (!stores?.length) return null;
        const options = stores.map((store) => ({
          value: getStoreIdentifier(store) || store.store_db || String(store.store_name || ''),
          label: store.store_name || store.store_db || `Store #${store.store_id}`,
        }));

        const selectedValue = getStoreIdentifier(selectedStore) || options[0]?.value || '';

        useEffect(() => {
          if (!selectedStore && options.length) {
            const first = stores.find((s) => getStoreIdentifier(s) === options[0].value) || stores[0];
            onChange(first);
          }
        }, [stores, selectedStore, onChange]);

        if (stores.length === 1) {
          return (
            <div>
              <span className="metric-label">Store</span>
              <div>{options[0]?.label}</div>
            </div>
          );
        }

        return (
          <label>
            Store
            <select
              value={selectedValue}
              onChange={(event) => {
                const selected = stores.find((store) => getStoreIdentifier(store) === event.target.value);
                onChange(selected);
              }}
            >
              {options.map((option) => (
                <option key={option.value} value={option.value}>
                  {option.label}
                </option>
              ))}
            </select>
          </label>
        );
      };

      const SalesChart = ({ sales }) => {
        const canvasRef = useRef(null);
        const chartRef = useRef(null);

        useEffect(() => {
          const canvas = canvasRef.current;
          if (!canvas) return;

          if (!sales?.length) {
            if (chartRef.current) {
              chartRef.current.destroy();
              chartRef.current = null;
            }
            return;
          }

          const labels = sales.map((item) => item.date).reverse();
          const totals = sales.map((item) => item.total_sales).reverse();
          const qty = sales.map((item) => item.total_items_sold).reverse();

          if (chartRef.current) {
            chartRef.current.data.labels = labels;
            chartRef.current.data.datasets[0].data = totals;
            chartRef.current.data.datasets[1].data = qty;
            chartRef.current.update();
            return;
          }

          chartRef.current = new Chart(canvas, {
            type: 'line',
            data: {
              labels,
              datasets: [
                {
                  label: 'Sales ($)',
                  data: totals,
                  borderColor: '#2563eb',
                  backgroundColor: 'rgba(37, 99, 235, 0.12)',
                  tension: 0.35,
                  fill: true,
                  yAxisID: 'y',
                },
                {
                  label: 'Items Sold',
                  data: qty,
                  borderColor: '#f97316',
                  backgroundColor: 'rgba(249, 115, 22, 0.12)',
                  tension: 0.35,
                  fill: true,
                  yAxisID: 'y1',
                },
              ],
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                y: {
                  position: 'left',
                  title: { display: true, text: 'Sales ($)' },
                },
                y1: {
                  position: 'right',
                  grid: { drawOnChartArea: false },
                  title: { display: true, text: 'Items' },
                },
              },
              plugins: {
                legend: { display: true },
                tooltip: { mode: 'index', intersect: false },
              },
            },
          });

          return () => {
            if (chartRef.current) {
              chartRef.current.destroy();
              chartRef.current = null;
            }
          };
        }, [sales]);

        if (!sales?.length) {
          return <div className="empty-state">No sales data available for charting.</div>;
        }

        return <canvas ref={canvasRef} height="220"></canvas>;
      };

      const SyncTable = ({ logs }) => {
        if (!logs?.length) {
          return <div className="empty-state">No sync activity logged yet.</div>;
        }

        const formatNumber = (value) => {
          if (value === null || value === undefined) return '—';
          const parsed = Number(value);
          return Number.isNaN(parsed) ? value : parsed.toLocaleString();
        };

        return (
          <div className="table-wrapper">
            <table>
              <thead>
                <tr>
                  <th>Store</th>
                  <th>Status</th>
                  <th>Started</th>
                  <th>Finished</th>
                  <th>Records</th>
                  <th>Message</th>
                </tr>
              </thead>
              <tbody>
                {logs.map((log) => (
                  <tr key={`${log.id}-${log.started_at}`}> 
                    <td>{log.store_name || log.store_db || '—'}</td>
                    <td>
                      <span className="status-pill" data-status={(log.status || '').toLowerCase()}>
                        {log.status || '—'}
                      </span>
                    </td>
                    <td>{log.started_at ? new Date(log.started_at).toLocaleString() : '—'}</td>
                    <td>{log.finished_at ? new Date(log.finished_at).toLocaleString() : '—'}</td>
                    <td>{formatNumber(log.records_processed)}</td>
                    <td>{log.message || '—'}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        );
      };

      const TabSwitcher = ({ activeTab, onChange, showAdmin }) => {
        return (
          <div className="tab-container">
            <div className="tab-group">
              <button
                type="button"
                className="tab-button"
                data-active={activeTab === 'dashboard'}
                onClick={() => onChange('dashboard')}
              >
                Dashboard
              </button>
              {showAdmin ? (
                <button
                  type="button"
                  className="tab-button"
                  data-active={activeTab === 'admin'}
                  onClick={() => onChange('admin')}
                >
                  Admin
                </button>
              ) : null}
            </div>
          </div>
        );
      };

      const AdminLoginForm = ({ onSubmit, isLoading, error }) => {
        const [apiKey, setApiKey] = useState('');
        const [localError, setLocalError] = useState('');

        const handleSubmit = async (event) => {
          event.preventDefault();
          const trimmed = apiKey.trim();
          if (!trimmed) {
            setLocalError('Admin key is required');
            return;
          }
          setLocalError('');
          const success = await onSubmit(trimmed);
          if (success) {
            setApiKey('');
          }
        };

        return (
          <form className="admin-form" onSubmit={handleSubmit}>
            <label>
              Admin API Key
              <input
                type="password"
                value={apiKey}
                onChange={(event) => setApiKey(event.target.value)}
                placeholder="Enter admin key"
                disabled={isLoading}
              />
            </label>
            {(error || localError) && <div className="error-message">{error || localError}</div>}
            <button type="submit" disabled={isLoading}>
              {isLoading ? 'Signing in…' : 'Sign in as admin'}
            </button>
          </form>
        );
      };

      const UserList = ({ users, selectedUserId, onSelectUser }) => {
        if (!users?.length) {
          return <div className="empty-state">No users found yet.</div>;
        }

        return (
          <ul className="user-list">
            {users.map((user) => (
              <li key={user.id}>
                <button
                  type="button"
                  data-active={selectedUserId === user.id}
                  onClick={() => onSelectUser(user.id)}
                >
                  <span className="user-email">{user.email}</span>
                  <span className="user-meta">{formatRole(user.user_role)}</span>
                  <span className="user-meta">{user.full_name || '—'}</span>
                  <span className="user-meta">
                    {(user.stores?.length || 0).toString()} store{user.stores?.length === 1 ? '' : 's'}
                  </span>
                </button>
              </li>
            ))}
          </ul>
        );
      };

      const CreateUserForm = ({ onSubmit, isSubmitting }) => {
        const [email, setEmail] = useState('');
        const [password, setPassword] = useState('');
        const [fullName, setFullName] = useState('');
        const [role, setRole] = useState('owner');
        const [storeDb, setStoreDb] = useState('');
        const [storeUser, setStoreUser] = useState('');
        const [storePass, setStorePass] = useState('');
        const [storeName, setStoreName] = useState('');
        const [formError, setFormError] = useState('');

        const handleSubmit = async (event) => {
          event.preventDefault();
          setFormError('');

          const trimmedEmail = email.trim();
          const trimmedPassword = password.trim();

          if (!trimmedEmail || !trimmedPassword) {
            setFormError('Email and password are required');
            return;
          }

          const trimmedStoreDb = storeDb.trim();
          const trimmedStoreUser = storeUser.trim();
          const storeFieldsFilled =
            trimmedStoreDb.length || trimmedStoreUser.length || storePass.trim().length || storeName.trim().length;

          if (storeFieldsFilled && (!trimmedStoreDb || !trimmedStoreUser || !storePass.trim())) {
            setFormError('Store database, user, and password are required to create an initial store assignment');
            return;
          }

          const stores = [];
          if (storeFieldsFilled) {
            stores.push({
              store_db: trimmedStoreDb,
              db_user: trimmedStoreUser,
              db_pass: storePass,
              store_name: storeName.trim() || undefined,
            });
          }

          const payload = {
            email: trimmedEmail,
            password: trimmedPassword,
            full_name: fullName.trim() || undefined,
            user_role: role,
            stores,
          };

          const success = await onSubmit(payload);
          if (success) {
            setEmail('');
            setPassword('');
            setFullName('');
            setRole('owner');
            setStoreDb('');
            setStoreUser('');
            setStorePass('');
            setStoreName('');
          }
        };

        return (
          <form className="admin-form" onSubmit={handleSubmit}>
            <h3>Create user</h3>
            <label>
              Email
              <input
                type="email"
                value={email}
                onChange={(event) => setEmail(event.target.value)}
                placeholder="manager@example.com"
                disabled={isSubmitting}
              />
            </label>
            <label>
              Password
              <input
                type="password"
                value={password}
                onChange={(event) => setPassword(event.target.value)}
                placeholder="Minimum 8 characters"
                disabled={isSubmitting}
              />
            </label>
            <label>
              Full name (optional)
              <input
                type="text"
                value={fullName}
                onChange={(event) => setFullName(event.target.value)}
                placeholder="Regional Manager"
                disabled={isSubmitting}
              />
            </label>
            <label>
              Role
              <select
                value={role}
                onChange={(event) => setRole(event.target.value)}
                disabled={isSubmitting}
              >
                <option value="owner">Owner</option>
                <option value="user">User</option>
                <option value="admin">Admin</option>
              </select>
            </label>
            <div className="metrics">
              <label>
                Store database (optional)
                <input
                  type="text"
                  value={storeDb}
                  onChange={(event) => setStoreDb(event.target.value)}
                  placeholder="spirits_6885"
                  disabled={isSubmitting}
                />
              </label>
              <label>
                DB user
                <input
                  type="text"
                  value={storeUser}
                  onChange={(event) => setStoreUser(event.target.value)}
                  placeholder="store_reader"
                  disabled={isSubmitting}
                />
              </label>
              <label>
                DB password
                <input
                  type="password"
                  value={storePass}
                  onChange={(event) => setStorePass(event.target.value)}
                  placeholder="secret"
                  disabled={isSubmitting}
                />
              </label>
              <label>
                Store name
                <input
                  type="text"
                  value={storeName}
                  onChange={(event) => setStoreName(event.target.value)}
                  placeholder="Downtown Spirits"
                  disabled={isSubmitting}
                />
              </label>
            </div>
            {formError && <div className="error-message">{formError}</div>}
            <button type="submit" disabled={isSubmitting}>
              {isSubmitting ? 'Creating user…' : 'Create user'}
            </button>
          </form>
        );
      };

      const AddStoreForm = ({ onSubmit, isSubmitting, user }) => {
        const [storeDb, setStoreDb] = useState('');
        const [storeUser, setStoreUser] = useState('');
        const [storePass, setStorePass] = useState('');
        const [storeName, setStoreName] = useState('');
        const [formError, setFormError] = useState('');

        const handleSubmit = async (event) => {
          event.preventDefault();
          setFormError('');

          const trimmedDb = storeDb.trim();
          const trimmedUser = storeUser.trim();
          const trimmedPass = storePass.trim();

          if (!trimmedDb || !trimmedUser || !trimmedPass) {
            setFormError('Database, user, and password are required');
            return;
          }

          const payload = {
            store_db: trimmedDb,
            db_user: trimmedUser,
            db_pass: storePass,
            store_name: storeName.trim() || undefined,
          };

          const success = await onSubmit(payload);
          if (success) {
            setStoreDb('');
            setStoreUser('');
            setStorePass('');
            setStoreName('');
          }
        };

        return (
          <form className="admin-form" onSubmit={handleSubmit}>
            <h3>Add store to {user?.email || 'user'}</h3>
            <div className="metrics">
              <label>
                Store database
                <input
                  type="text"
                  value={storeDb}
                  onChange={(event) => setStoreDb(event.target.value)}
                  placeholder="spirits_6885"
                  disabled={isSubmitting}
                />
              </label>
              <label>
                DB user
                <input
                  type="text"
                  value={storeUser}
                  onChange={(event) => setStoreUser(event.target.value)}
                  placeholder="store_reader"
                  disabled={isSubmitting}
                />
              </label>
              <label>
                DB password
                <input
                  type="password"
                  value={storePass}
                  onChange={(event) => setStorePass(event.target.value)}
                  placeholder="secret"
                  disabled={isSubmitting}
                />
              </label>
              <label>
                Store name (optional)
                <input
                  type="text"
                  value={storeName}
                  onChange={(event) => setStoreName(event.target.value)}
                  placeholder="Downtown Spirits"
                  disabled={isSubmitting}
                />
              </label>
            </div>
            {formError && <div className="error-message">{formError}</div>}
            <button type="submit" disabled={isSubmitting}>
              {isSubmitting ? 'Adding store…' : 'Add store'}
            </button>
          </form>
        );
      };

      const StoreAssignments = ({ user, onRemoveStore, isProcessing }) => {
        if (!user?.stores?.length) {
          return <div className="empty-state">No store assignments yet.</div>;
        }

        return (
          <div className="store-list">
            {user.stores.map((store) => {
              const identifier = store.id ?? store.store_db ?? 'legacy';
              return (
                <div className="store-card" key={`${user.id}-${identifier}`}>
                  <div className="store-card-heading">
                    <h4>{store.store_name || store.store_db || 'Store'}</h4>
                    <button
                      type="button"
                      className="secondary-button"
                      onClick={() => onRemoveStore(user.id, identifier)}
                      disabled={isProcessing}
                    >
                      Remove
                    </button>
                  </div>
                  <dl className="store-card-details">
                    <div className="store-card-detail">
                      <dt>Database</dt>
                      <dd>{store.store_db || '—'}</dd>
                    </div>
                    <div className="store-card-detail">
                      <dt>DB user</dt>
                      <dd>{store.db_user || '—'}</dd>
                    </div>
                    <div className="store-card-detail">
                      <dt>DB password</dt>
                      <dd>{store.db_pass || '—'}</dd>
                    </div>
                    <div className="store-card-detail">
                      <dt>Store name</dt>
                      <dd>{store.store_name || '—'}</dd>
                    </div>
                  </dl>
                </div>
              );
            })}
          </div>
        );
      };

      const AdminPanel = ({
        users,
        selectedUserId,
        onSelectUser,
        onLogout,
        onRefresh,
        onCreateUser,
        onAddStore,
        onRemoveStore,
        isLoading,
        isProcessing,
        error,
        message,
      }) => {
        const selectedUser = users.find((user) => user.id === selectedUserId) || users[0] || null;

        useEffect(() => {
          if (!selectedUser && users.length) {
            onSelectUser(users[0].id);
          }
        }, [users, selectedUser, onSelectUser]);

        return (
          <div className="admin-grid">
            <section className="card">
              <div className="admin-toolbar">
                <div>
                  <h2>Users</h2>
                  <span className="user-meta">Manage dashboard accounts and their stores.</span>
                </div>
                <div className="control-actions">
                  <button
                    type="button"
                    className="secondary-button"
                    onClick={onRefresh}
                    disabled={isLoading || isProcessing}
                  >
                    Refresh
                  </button>
                  <button
                    type="button"
                    className="secondary-button"
                    onClick={() => onLogout()}
                    disabled={isProcessing}
                  >
                    Sign out
                  </button>
                </div>
              </div>
              {error && <div className="error-message">{error}</div>}
              {message && <div className="success-message">{message}</div>}
              {isLoading ? (
                <div className="empty-state">Loading users…</div>
              ) : (
                <UserList users={users} selectedUserId={selectedUser?.id} onSelectUser={onSelectUser} />
              )}
              <CreateUserForm onSubmit={onCreateUser} isSubmitting={isProcessing} />
            </section>
            <section className="card">
              <h2>Store assignments</h2>
              {selectedUser ? (
                <>
                  <div className="metrics">
                    <div>
                      <span className="metric-label">User</span>
                      <span>{selectedUser.email}</span>
                    </div>
                  <div>
                    <span className="metric-label">Name</span>
                    <span>{selectedUser.full_name || '—'}</span>
                  </div>
                  <div>
                    <span className="metric-label">Role</span>
                    <span>{formatRole(selectedUser.user_role)}</span>
                  </div>
                  <div>
                    <span className="metric-label">Stores</span>
                    <span>{selectedUser.stores?.length || 0}</span>
                  </div>
                  </div>
                  <StoreAssignments
                    user={selectedUser}
                    onRemoveStore={onRemoveStore}
                    isProcessing={isProcessing}
                  />
                  <AddStoreForm
                    user={selectedUser}
                    onSubmit={(payload) => onAddStore(selectedUser.id, payload)}
                    isSubmitting={isProcessing}
                  />
                </>
              ) : (
                <div className="empty-state">Select a user to manage their stores.</div>
              )}
            </section>
          </div>
        );
      };

      const AdminView = ({
        hasKey,
        onLogin,
        onLogout,
        users,
        selectedUserId,
        onSelectUser,
        onRefresh,
        onCreateUser,
        onAddStore,
        onRemoveStore,
        isLoading,
        isProcessing,
        error,
        message,
      }) => {
        if (!hasKey) {
          return (
            <section className="card">
              <h2>Admin access</h2>
              <p className="user-meta">
                Provide the admin API key configured on the server to manage users and store assignments.
              </p>
              <AdminLoginForm onSubmit={onLogin} isLoading={isLoading} error={error} />
            </section>
          );
        }

        return (
          <AdminPanel
            users={users}
            selectedUserId={selectedUserId}
            onSelectUser={onSelectUser}
            onLogout={onLogout}
            onRefresh={onRefresh}
            onCreateUser={onCreateUser}
            onAddStore={onAddStore}
            onRemoveStore={onRemoveStore}
            isLoading={isLoading}
            isProcessing={isProcessing}
            error={error}
            message={message}
          />
        );
      };

      const LoginForm = ({ onSubmit, isLoading, error }) => {
        const [email, setEmail] = useState('');
        const [password, setPassword] = useState('');

        const submit = (event) => {
          event.preventDefault();
          onSubmit({ email, password });
        };

        return (
          <form onSubmit={submit}>
            <label htmlFor="email">
              Email
              <input
                id="email"
                type="email"
                placeholder="you@example.com"
                value={email}
                onChange={(event) => setEmail(event.target.value)}
                required
              />
            </label>
            <label htmlFor="password">
              Password
              <input
                id="password"
                type="password"
                placeholder="••••••••"
                value={password}
                onChange={(event) => setPassword(event.target.value)}
                required
              />
            </label>
            {error ? <div className="error-message">{error}</div> : null}
            <button type="submit" disabled={isLoading}>
              {isLoading ? 'Signing in…' : 'Sign in'}
            </button>
          </form>
        );
      };

      const Dashboard = ({
        stores,
        selectedStore,
        sales,
        syncLogs,
        onStoreChange,
        onRefresh,
        onLogout,
        loading,
        error,
      }) => {
        const summary = useMemo(() => {
          return sales.reduce(
            (acc, day) => {
              acc.sales += Number(day.total_sales || 0);
              acc.items += Number(day.total_items_sold || 0);
              return acc;
            },
            { sales: 0, items: 0 }
          );
        }, [sales]);

        return (
          <>
            {error ? (
              <section className="card error-card">
                <h2>Heads up</h2>
                <p>{error}</p>
              </section>
            ) : null}

            <section className="card">
              <h2>Store Controls</h2>
              <div className="controls">
                <StoreSelector stores={stores} selectedStore={selectedStore} onChange={onStoreChange} />
                <div className="control-actions">
                  <button type="button" onClick={onRefresh} disabled={loading}>
                    {loading ? 'Refreshing…' : 'Refresh insights'}
                  </button>
                  <button type="button" className="secondary-button" onClick={onLogout}>
                    Sign out
                  </button>
                </div>
              </div>
            </section>

            <section className="card">
              <h2>7-Day Summary</h2>
              {sales.length ? (
                <div className="metrics">
                  <div>
                    <span className="metric-label">Gross sales</span>
                    <span className="metric-value">
                      ${summary.sales.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}
                    </span>
                  </div>
                  <div>
                    <span className="metric-label">Items sold</span>
                    <span className="metric-value">{summary.items.toLocaleString()}</span>
                  </div>
                  <div>
                    <span className="metric-label">Days captured</span>
                    <span className="metric-value">{sales.length}</span>
                  </div>
                </div>
              ) : (
                <div className="empty-state">No sales recorded in the last 7 days.</div>
              )}
            </section>

            <section className="card">
              <h2>Daily Sales</h2>
              {sales.length ? (
                <table>
                  <thead>
                    <tr>
                      <th>Date</th>
                      <th>Items Sold</th>
                      <th>Total Sales ($)</th>
                    </tr>
                  </thead>
                  <tbody>
                    {sales.map((sale) => (
                      <tr key={sale.date}>
                        <td>{sale.date}</td>
                        <td>{sale.total_items_sold}</td>
                        <td>{sale.total_sales.toLocaleString(undefined, { minimumFractionDigits: 2 })}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              ) : (
                <div className="empty-state">No sales recorded in the last 7 days.</div>
              )}
            </section>

            <section className="card">
              <h2>Sales Trend (7 Days)</h2>
              <SalesChart sales={sales} />
            </section>

            <section className="card">
              <h2>DBF Sync Activity</h2>
              <SyncTable logs={syncLogs} />
            </section>
          </>
        );
      };

      const App = () => {
        const [activeTab, setActiveTab] = useState('dashboard');
        const [token, setToken] = useState(() => storage.get(STORAGE_KEYS.token, null));
        const [userRole, setUserRole] = useState(() => storage.get(STORAGE_KEYS.role, ''));
        const [stores, setStores] = useState(() => storage.get(STORAGE_KEYS.stores, []));
        const [selectedStore, setSelectedStore] = useState(() =>
          storage.get(STORAGE_KEYS.selectedStore, null)
        );
        const [sales, setSales] = useState([]);
        const [syncLogs, setSyncLogs] = useState([]);
        const [authError, setAuthError] = useState('');
        const [isAuthenticating, setIsAuthenticating] = useState(false);
        const [isLoadingData, setIsLoadingData] = useState(false);

        const [adminKey, setAdminKey] = useState(() => storage.get(STORAGE_KEYS.adminKey, ''));
        const [adminUsers, setAdminUsers] = useState([]);
        const [selectedAdminUserId, setSelectedAdminUserId] = useState(null);
        const [adminError, setAdminError] = useState('');
        const [adminMessage, setAdminMessage] = useState('');
        const [isAdminLoading, setIsAdminLoading] = useState(false);
        const [isAdminProcessing, setIsAdminProcessing] = useState(false);

        const tokenRef = useRef(token);

        const storeQueryValue = useMemo(() => {
          const identifier = getStoreIdentifier(selectedStore);
          return identifier ? `?store=${encodeURIComponent(identifier)}` : '';
        }, [selectedStore]);

        const handleLogout = useCallback((message = '') => {
          storage.clearSession();
          setToken(null);
          setUserRole('');
          setStores([]);
          setSelectedStore(null);
          setSales([]);
          setSyncLogs([]);
          tokenRef.current = null;
          setAuthError(message);
          setIsAuthenticating(false);
          setIsLoadingData(false);
          setActiveTab('dashboard');
        }, []);

        const handleAdminLogout = useCallback(
          (message = '') => {
            setAdminKey('');
            storage.remove(STORAGE_KEYS.adminKey);
            setAdminUsers([]);
            setSelectedAdminUserId(null);
            setIsAdminLoading(false);
            setIsAdminProcessing(false);
            setAdminMessage('');
            setAdminError(message);
          },
          []
        );

        useEffect(() => {
          tokenRef.current = token;
          if (token) {
            storage.set(STORAGE_KEYS.token, token);
          } else {
            storage.remove(STORAGE_KEYS.token);
          }
        }, [token]);

        useEffect(() => {
          if (!token || userRole) {
            return;
          }
          const decodedRole = decodeRoleFromToken(token);
          if (decodedRole) {
            setUserRole(decodedRole);
          }
        }, [token, userRole]);

        useEffect(() => {
          if (userRole) {
            storage.set(STORAGE_KEYS.role, userRole);
          } else {
            storage.remove(STORAGE_KEYS.role);
          }
        }, [userRole]);

        useEffect(() => {
          if (stores?.length) {
            storage.set(STORAGE_KEYS.stores, stores);
          } else {
            storage.remove(STORAGE_KEYS.stores);
          }
        }, [stores]);

        useEffect(() => {
          if (selectedStore) {
            storage.set(STORAGE_KEYS.selectedStore, selectedStore);
          } else {
            storage.remove(STORAGE_KEYS.selectedStore);
          }
        }, [selectedStore]);

        useEffect(() => {
          if (adminKey) {
            storage.set(STORAGE_KEYS.adminKey, adminKey);
          } else {
            storage.remove(STORAGE_KEYS.adminKey);
          }
        }, [adminKey]);

        useEffect(() => {
          if (userRole !== 'admin' && adminKey) {
            handleAdminLogout();
          }
        }, [userRole, adminKey, handleAdminLogout]);

        useEffect(() => {
          if (activeTab === 'admin' && userRole !== 'admin') {
            setActiveTab('dashboard');
          }
        }, [activeTab, userRole]);

        useEffect(() => {
          if (!stores?.length) {
            if (selectedStore) {
              setSelectedStore(null);
            }
            return;
          }

          if (!selectedStore) {
            setSelectedStore(stores[0]);
            return;
          }

          const identifier = getStoreIdentifier(selectedStore);
          const match = stores.find((store) => getStoreIdentifier(store) === identifier);
          if (!match) {
            setSelectedStore(stores[0]);
          } else if (match !== selectedStore) {
            setSelectedStore(match);
          }
        }, [stores, selectedStore]);

        useEffect(() => {
          const storeMeta = document.getElementById('store-meta');
          if (!storeMeta) return;

          if (activeTab === 'admin' && userRole === 'admin') {
            storeMeta.textContent = 'Admin tools';
            return;
          }

          if (!token) {
            storeMeta.textContent = '';
            return;
          }

          const name = selectedStore?.store_name || selectedStore?.store_db;
          storeMeta.textContent = name ? `Viewing ${name}` : 'Select a store to begin';
        }, [activeTab, token, selectedStore, userRole]);

        const fetchSales = async (authToken, query) => {
          const response = await fetch(`${API_BASE}/insights/sales${query}`, {
            headers: { Authorization: `Bearer ${authToken}` },
          });
          let payload = {};
          try {
            payload = await response.json();
          } catch (error) {
            payload = {};
          }
          if (!response.ok) {
            const requestError = new Error(payload.detail || 'Unable to load sales data');
            requestError.status = response.status;
            throw requestError;
          }
          return payload.sales || [];
        };

        const fetchSyncLogs = async (authToken, query) => {
          const response = await fetch(`${API_BASE}/sync/status${query}`, {
            headers: { Authorization: `Bearer ${authToken}` },
          });
          let payload = {};
          try {
            payload = await response.json();
          } catch (error) {
            payload = {};
          }
          if (!response.ok) {
            const requestError = new Error(payload.detail || 'Unable to load sync data');
            requestError.status = response.status;
            throw requestError;
          }
          return payload.logs || [];
        };

        const loadInsights = async (authToken, query) => {
          if (!authToken) return;
          setIsLoadingData(true);
          try {
            const [salesData, syncData] = await Promise.all([
              fetchSales(authToken, query),
              fetchSyncLogs(authToken, query),
            ]);
            if (authToken !== tokenRef.current) {
              return;
            }
            setSales(salesData);
            setSyncLogs(syncData);
            setAuthError('');
          } catch (error) {
            console.error(error);
            if (error.status === 401) {
              handleLogout('Session expired. Please sign in again.');
              return;
            }
            setAuthError(error.message || 'Unable to load dashboard data');
          } finally {
            setIsLoadingData(false);
          }
        };

        useEffect(() => {
          if (!token) return;
          if (stores.length > 1 && !selectedStore) return;
          loadInsights(token, storeQueryValue);
        }, [token, storeQueryValue, stores, selectedStore]);

        const loadAdminUsers = useCallback(
          async (key) => {
            if (!key) {
              setAdminUsers([]);
              setSelectedAdminUserId(null);
              return [];
            }
            setIsAdminLoading(true);
            try {
              const response = await fetch(`${API_BASE}/admin/users`, {
                headers: { 'X-Admin-Key': key },
              });
              let data = {};
              try {
                data = await response.json();
              } catch (error) {
                data = {};
              }
              if (!response.ok) {
                const requestError = new Error(data.detail || 'Unable to load admin data');
                requestError.status = response.status;
                throw requestError;
              }
              const users = data.users || [];
              setAdminUsers(users);
              if (!users.length) {
                setSelectedAdminUserId(null);
              } else if (
                !selectedAdminUserId ||
                !users.some((user) => user.id === selectedAdminUserId)
              ) {
                setSelectedAdminUserId(users[0].id);
              }
              return users;
            } catch (error) {
              setAdminUsers([]);
              setSelectedAdminUserId(null);
              throw error;
            } finally {
              setIsAdminLoading(false);
            }
          },
          [selectedAdminUserId]
        );

        const handleAdminLogin = useCallback(
          async (key) => {
            setAdminError('');
            setAdminMessage('');
            try {
              await loadAdminUsers(key);
              setAdminKey(key);
              return true;
            } catch (error) {
              if (error.status === 401) {
                setAdminError('Invalid admin key');
              } else {
                setAdminError(error.message || 'Unable to authenticate admin');
              }
              return false;
            }
          },
          [loadAdminUsers]
        );

        const handleAdminRefresh = useCallback(() => {
          if (!adminKey) return;
          setAdminError('');
          loadAdminUsers(adminKey).catch((error) => {
            if (error.status === 401) {
              handleAdminLogout('Admin key rejected. Please sign in again.');
            } else {
              setAdminError(error.message || 'Unable to refresh admin data');
            }
          });
        }, [adminKey, loadAdminUsers, handleAdminLogout]);

        useEffect(() => {
          if (activeTab !== 'admin' || !adminKey) return;
          setAdminError('');
          loadAdminUsers(adminKey).catch((error) => {
            if (error.status === 401) {
              handleAdminLogout('Admin key rejected. Please sign in again.');
            } else {
              setAdminError(error.message || 'Unable to load admin data');
            }
          });
        }, [activeTab, adminKey, loadAdminUsers, handleAdminLogout]);

        const handleAdminCreateUser = useCallback(
          async (payload) => {
            if (!adminKey) {
              setAdminError('Admin session not active');
              return false;
            }
            setIsAdminProcessing(true);
            setAdminError('');
            setAdminMessage('');
            try {
              const response = await fetch(`${API_BASE}/admin/users`, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'X-Admin-Key': adminKey,
                },
                body: JSON.stringify(payload),
              });
              let data = {};
              try {
                data = await response.json();
              } catch (error) {
                data = {};
              }
              if (!response.ok) {
                const requestError = new Error(data.detail || 'Failed to create user');
                requestError.status = response.status;
                throw requestError;
              }
              const users = await loadAdminUsers(adminKey);
              const newUser = users.find((user) => user.id === data.id);
              if (newUser) {
                setSelectedAdminUserId(newUser.id);
              }
              setAdminMessage('User created successfully');
              return true;
            } catch (error) {
              if (error.status === 401) {
                handleAdminLogout('Admin session expired. Please sign in again.');
              } else {
                setAdminError(error.message || 'Failed to create user');
              }
              return false;
            } finally {
              setIsAdminProcessing(false);
            }
          },
          [adminKey, loadAdminUsers, handleAdminLogout]
        );

        const handleAdminAddStore = useCallback(
          async (userId, payload) => {
            if (!adminKey) {
              setAdminError('Admin session not active');
              return false;
            }
            setIsAdminProcessing(true);
            setAdminError('');
            setAdminMessage('');
            try {
              const response = await fetch(`${API_BASE}/admin/users/${userId}/stores`, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'X-Admin-Key': adminKey,
                },
                body: JSON.stringify(payload),
              });
              let data = {};
              try {
                data = await response.json();
              } catch (error) {
                data = {};
              }
              if (!response.ok) {
                const requestError = new Error(data.detail || 'Failed to add store');
                requestError.status = response.status;
                throw requestError;
              }
              await loadAdminUsers(adminKey);
              setSelectedAdminUserId(userId);
              setAdminMessage('Store added successfully');
              return true;
            } catch (error) {
              if (error.status === 401) {
                handleAdminLogout('Admin session expired. Please sign in again.');
              } else {
                setAdminError(error.message || 'Failed to add store');
              }
              return false;
            } finally {
              setIsAdminProcessing(false);
            }
          },
          [adminKey, loadAdminUsers, handleAdminLogout]
        );

        const handleAdminRemoveStore = useCallback(
          async (userId, identifier) => {
            if (!adminKey) {
              setAdminError('Admin session not active');
              return;
            }
            setIsAdminProcessing(true);
            setAdminError('');
            setAdminMessage('');
            try {
              const response = await fetch(
                `${API_BASE}/admin/users/${userId}/stores/${encodeURIComponent(identifier)}`,
                {
                  method: 'DELETE',
                  headers: {
                    'X-Admin-Key': adminKey,
                  },
                }
              );
              let data = {};
              try {
                data = await response.json();
              } catch (error) {
                data = {};
              }
              if (!response.ok) {
                const requestError = new Error(data.detail || 'Failed to remove store');
                requestError.status = response.status;
                throw requestError;
              }
              await loadAdminUsers(adminKey);
              setSelectedAdminUserId(userId);
              setAdminMessage('Store removed successfully');
            } catch (error) {
              if (error.status === 401) {
                handleAdminLogout('Admin session expired. Please sign in again.');
              } else {
                setAdminError(error.message || 'Failed to remove store');
              }
            } finally {
              setIsAdminProcessing(false);
            }
          },
          [adminKey, loadAdminUsers, handleAdminLogout]
        );

        const handleLogin = async ({ email, password }) => {
          setIsAuthenticating(true);
          setAuthError('');
          try {
            const response = await fetch(`${API_BASE}/auth/login`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ email, password }),
            });

            let data = {};
            try {
              data = await response.json();
            } catch (error) {
              data = {};
            }
            if (!response.ok) {
              throw new Error(data.detail || 'Login failed');
            }

            setToken(data.token);
            setUserRole(data.role || 'owner');
            setStores(data.stores || []);
            if (data.stores?.length) {
              setSelectedStore(data.stores[0]);
            } else {
              setSelectedStore(null);
            }
            setActiveTab('dashboard');
          } catch (error) {
            setAuthError(error.message);
          } finally {
            setIsAuthenticating(false);
          }
        };

        const refresh = () => {
          if (token) {
            loadInsights(token, storeQueryValue);
          }
        };

        const dashboardContent = token ? (
          <Dashboard
            stores={stores}
            selectedStore={selectedStore}
            sales={sales}
            syncLogs={syncLogs}
            onStoreChange={setSelectedStore}
            onRefresh={refresh}
            onLogout={handleLogout}
            loading={isLoadingData}
            error={authError}
          />
        ) : (
          <section className="card">
            <h2>Sign in</h2>
            <LoginForm onSubmit={handleLogin} isLoading={isAuthenticating} error={authError} />
          </section>
        );

        const adminContent = (
          <AdminView
            hasKey={Boolean(adminKey)}
            onLogin={handleAdminLogin}
            onLogout={handleAdminLogout}
            users={adminUsers}
            selectedUserId={selectedAdminUserId}
            onSelectUser={setSelectedAdminUserId}
            onRefresh={handleAdminRefresh}
            onCreateUser={handleAdminCreateUser}
            onAddStore={handleAdminAddStore}
            onRemoveStore={handleAdminRemoveStore}
            isLoading={isAdminLoading}
            isProcessing={isAdminProcessing}
            error={adminError}
            message={adminMessage}
          />
        );

        const canAccessAdmin = userRole === 'admin';
        const handleTabChange = useCallback(
          (tab) => {
            if (tab === 'admin' && !canAccessAdmin) {
              return;
            }
            setActiveTab(tab);
          },
          [canAccessAdmin]
        );

        const displayedTab = canAccessAdmin ? activeTab : 'dashboard';
        const currentContent =
          displayedTab === 'admin' && canAccessAdmin ? adminContent : dashboardContent;

        return (
          <>
            <TabSwitcher
              activeTab={displayedTab}
              onChange={handleTabChange}
              showAdmin={canAccessAdmin}
            />
            {currentContent}
          </>
        );
      };

      ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
  </body>
</html>
